<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="2.6.3_2" segtype="paragraph" srclang="EN-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="EN-US">
        <seg># Aligned with opening delimiter
    foo = long_function_name(var_one, var_two,
                             var_three, var_four)</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150054Z">
        <seg># 구분자를 사용하여 정렬하기
    foo = long_function_name(var_one, var_two,
                             var_three, var_four)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Arguments on first line forbidden when not using vertical alignment
    foo = long_function_name(var_one, var_two,
        var_three, var_four)</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150127Z">
        <seg># 수직 정렬을 하지 않는다면, 인수를 첫 번째 줄에 사용하지 마라.
    foo = long_function_name(var_one, var_two,
        var_three, var_four)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Extra indentation is not necessary.
    foo = long_function_name(
      var_one, var_two,
      var_three, var_four)</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150158Z">
        <seg># 부가적인 들여쓰기는 딱히 사용하지 않아도 된다.
    foo = long_function_name(
      var_one, var_two,
      var_three, var_four)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># Further indentation required as indentation is not distinguishable
    def long_function_name(
        var_one, var_two, var_three,
        var_four):
        print(var_one)</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150131Z">
        <seg># 다음 행과 구별이 안 되므로 추가적인 들여쓰기가 필요하다.
    def long_function_name(
        var_one, var_two, var_three,
        var_four):
        print(var_one)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># More indentation included to distinguish this from the rest.
    def long_function_name(
            var_one, var_two, var_three,
            var_four):
        print(var_one)</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150104Z">
        <seg># 나머지 코드와의 구별을 위해 추가적인 들여쓰기를 사용했다.
    def long_function_name(
            var_one, var_two, var_three,
            var_four):
        print(var_one)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Let's hope that these variables are meant for use inside one module
only.)  The conventions are about the same as those for functions.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153243Z">
        <seg>(해당 변수는 하나의 모듈 내부에서만 쓰인다고 생각하도록 하자)  이 규칙은
함수에도 동일하게 적용된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* A further issue was that annotations become part of the
    specification but weren't being tested.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T155930Z">
        <seg>* 어노테이션은 명세에 포함되어 있으나 테스트가 이루어지지 않았다는
    것 또한 문제가 되었다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Add the PEP to a local clone of the PEP repository.  For mercurial workflow
  instructions, follow `The Python Developers Guide &lt;http://docs.python.org/devguide&gt;`_</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T043621Z">
        <seg>* PEP를 PEP 저장소의 로컬 복제본에 추가한다.  머큐리얼 작업 흐름에
  대해서는 `Python 개발자 안내서 &lt;http://docs.python.org/devguide/&gt;`_\ 의
  지침을 따른다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* All function declarations and definitions must use full prototypes
  (i.e. specify the types of all arguments).</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T044538Z">
        <seg>* 모든 함수 선언 및 정의는 반드시 완전한 프로토타입을 사용한다(즉,
  모든 인자의 형을 명시한다).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* All functions and global variables should be declared static unless
  they are to be part of a published interface</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T053440Z">
        <seg>* 이미 나와있는 인터페이스의 일부가 아닌 한, 모든 함수와 전역 변수는
  정적으로 선언되어야 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Always put spaces around assignment, Boolean and comparison
  operators.  In expressions using a lot of operators, add spaces
  around the outermost (lowest-priority) operators.</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T052529Z">
        <seg>* 할당, 불리언 및 비교 연산자 주위에는 항상 공백을 둔다.  연산자를
  많이 사용하는 표현식에서는, (우선순위가 가장 낮은) 가장 바깥쪽
  연산자 주면에 공백을 추가한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Annotations such as ``read1(n: int=None)`` were self-contradictory
    since *None* is not an *int*.  Annotations such as
    ``source_path(self, fullname:str) -&gt; object`` were confusing about
    what the return type should be.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T155718Z">
        <seg>* ``read1(n: int=None)`` 어노테이션은 모순적이다. None은 int가
    아니기 때문이다. ``source_path(self, fullname:str) -&gt; object``\ 와
    같은 어노테이션은 반환 타입이 무엇인지 혼동할 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Assign a PEP number (almost always just the next available number,
  but sometimes it's a special/joke number, like 666 or 3141).
  (Clarification: For Python 3, numbers in the 3000s were used for
  Py3k-specific proposals.  But now that all new features go into
  Python 3 only, the process is back to using numbers in the 100s again.
  Remember that numbers below 100 are meta-PEPs.)</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T025809Z">
        <seg>* PEP 번호를 할당(사용가능한 다음 번호를 붙이는 경우가 대부분이지만, 가끔은
  666이나 3141처럼 특별한 번호나 장난스러운 번호를 붙이기도 한다).
  (설명: Python 3에서는, Py3k에 한정된 제안에 대하여 3000번대 번호를
  사용했다. 그러나 이제는 모든 기능이 Python 3에만 들어가게 되었으므로,
  100번대 번호를 붙이는 프로세스로 되돌려졌다. 100 아래의 번호는 메타
  PEP임을 기억하라.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Breaking long lines: if you can, break after commas in the outermost
  argument list.  Always indent continuation lines appropriately,
  e.g.::</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T052732Z">
        <seg>* 긴 행을 나누기: 가능하다면, 가장 바깥쪽의 인자 리스트의 쉼표 뒤에서
  행을 나눈다.  다음과 같이 항상 들여쓰기를 적절하게 사용한다. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Code structure: one space between keywords like ``if``, ``for`` and
  the following left paren; no spaces inside the paren; braces may be
  omitted where C permits but when present, they should be formatted
  as shown::</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T052343Z">
        <seg>* 코드 구조: ``if``, ``for``\ 와 같은 키워드 뒤에 한 칸을 띄운 후에
  괄호를 열고, 괄호 안쪽에는 공백을 두지 않는다.  C에서 허용할 경우
  괄호를 생략할 수 있으나, 괄호를 사용할 경우에는 다음과 같은
  형식을 따라야 한다. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Comments go before the code they describe.</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T053026Z">
        <seg>* 주석문은 해당 코드보다 먼저 오도록 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Commit and push the new (or updated) PEP</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T040444Z">
        <seg>* 새로운(또는 수정된) PEP를 commit 및 push한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Don't use GCC extensions (e.g. don't write multi-line strings
  without trailing backslashes).</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T044522Z">
        <seg>* GCC 확장을 사용하지 않는다(예를 들어, 줄 끝에 백슬래쉬 없이 여러
  줄에 걸친 문자열을 쓰지 않도록 한다).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Edit the PEP for language (spelling, grammar, sentence structure,
  etc.), markup (for reST PEPs), code style (examples should match PEP
  8 &amp; 7).</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T043221Z">
        <seg>* PEP의 언어(맞춤법, 문법, 문장 구조 등), 마크업(reST PEP에 해당), 코드
  스타일(PEP 8 및 7에 부합) 등에 대하여 편집한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* For external functions and variables, we always have a declaration
  in an appropriate header file in the "Include" directory, which uses
  the ``PyAPI_FUNC()`` macro, like this::</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T053448Z">
        <seg>* 외부 함수 및 변수에 대해서는, 우리는 항상 다음과 같이 "Include"
  디렉토리 내의 ``PyAPI_FUNC()`` 매크로를 사용하는 적절한 헤더 파일에
  그 정의를 둔다. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Function and macro call style: ``foo(a, b, c)`` -- no space before
  the open paren, no spaces inside the parens, no spaces before
  commas, one space after each comma.</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T052322Z">
        <seg>* 함수 및 매크로 호출 스타일: ``foo(a, b, c)`` -- 괄호 앞뒤에 공백을
  두지 않으며, 쉼표 앞에는 공백을 두지 않고, 쉼표 뒤에 공백 한 칸을
  둔다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Function definition style: function name in column 1, outermost
  curly braces in column 1, blank line after local variable
  declarations.  ::</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T052348Z">
        <seg>* 함수 정의 스타일: 함수 이름을 첫 컬럼에, 가장 바깥쪽 중괄호를
  첫 컬럼에 쓰고, 지역 변수 선언 후에 빈 줄을 둔다.  ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* In addition to the above, annotations were inconsistent in the use
    of concrete types versus abstract types:  *int* versus *Integral*
    and set/frozenset versus MutableSet/Set.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T155757Z">
        <seg>* 또한, 어노테이션은 구체화(concrete) 타입과 추상 타입의 사용에 있어
    일관성이 없다: *int*\ 와 *Integral*, set/frozenset과 MutableSet/
    Set을 들 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* In most cases, the docstrings already included the type
    specifications and did so with greater clarity than the function
    annotations.  In the remaining cases, the docstrings were improved
    once the annotations were removed.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T155948Z">
        <seg>* 대부분의 경우, docstring이 이미 타입 명세에 포함되어 있었으며
    함수 어노테이션보다 더 명확했다.  그 외의 경우, 어노테이션이
    삭제된 후 docstring의 내용이 개선되었다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Macros should have a MixedCase prefix and then use upper case, for
  example: ``PyString_AS_STRING``, ``Py_PRINT_RAW``.</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T054621Z">
        <seg>* 매크로는 대소문자를 섞은 접두어 뒤에 대문자를 쓴다. 예:
 ``PyString_AS_STRING``, ``Py_PRINT_RAW``</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Monitor python.org to make sure the PEP gets added to the site
  properly. If it fails to appear, running ``make`` will build all of the
  current PEPs. If any of these are triggering errors, they must be
  corrected before any PEP will update on the site.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T040655Z">
        <seg>* python.org를 모니터하여 PEP가 사이트에 적합하게 추가되었는지 확인한다.
  사이트에서 보이지 않는다면, ``make``\ 를 실행하여 현재의 모든 PEP를
  빌드한다.  그중 어느 것이라도 오류를 일으킨다면, PEP가 사이트에 반영되기
  전에 수정하여야 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Never use C++ style // one-line comments.</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T044131Z">
        <seg>* C++ 스타일의 // 한 줄 주석문을 절대 사용하지 마라.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* No compiler warnings with major compilers (gcc, VC++, a few others).</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T044549Z">
        <seg>* 주요한 컴파일러(gcc, VC++ 등)에서 컴파일러 경고가 발생하지 않도록
  하라.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* No line should be longer than 79 characters.  If this and the
  previous rule together don't give you enough room to code, your code
  is too complicated -- consider using subroutines.</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T044440Z">
        <seg>* 79자를 넘기는 행이 없도록 한다.  이것과 앞의 규칙을 함께 적용했을 때
  코드를 작성할 공간이 부족하다면, 당신의 코드가 너무 복잡한 것이므로
  서브루틴의 사용을 고려하라.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* No line should end in whitespace.  If you think you need significant
  trailing whitespace, think again -- somebody's editor might delete
  it as a matter of routine.</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T044841Z">
        <seg>* 공백으로 끝나는 행을 두지 마라.  특별한 의미를 갖는 공백을 줄 끝에
  두어야겠다면, 다시 한번 생각해보기 바란다.  다른 사람이 사용하는
  편집기에서는 자동으로 지워버릴 수도 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Occasionally an "internal" function has to be visible to the loader;
  we use the ``_Py`` prefix for this, e.g.: ``_PyObject_Dump``.</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T054038Z">
        <seg>* 가끔 "내부적인" 함수가 로더에 보여질 필요가 있는데, 이때에는
  ``_PyObject_Dump``\ 와 같이 ``_Py``\ 를 붙인다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Public functions and variables use MixedCase with underscores, like
  this: ``PyObject_GetAttr``, ``Py_BuildValue``, ``PyExc_TypeError``.</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T054614Z">
        <seg>* 퍼블릭 함수와 변수는 다음과 같이 밑줄과 대소문자를 섞어 쓴다:
  ``PyObject_GetAttr``, ``Py_BuildValue``, ``PyExc_TypeError``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Put blank lines around functions, structure definitions, and major
  sections inside functions.</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T053436Z">
        <seg>* 함수, 구조체 정의, 그리고 함수 내의 주요 섹션의 주변에는 빈 행을
  둔다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Read the PEP to check if it is ready: sound and complete.  The ideas
  must make technical sense, even if they don't seem likely to be
  accepted.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T024712Z">
        <seg>* PEP를 읽고 내용이 올바르고 완전하여 준비가 되었는지 점검한다.  수용되지
  못할 것 같아 보이는 아이디어라 할지라도 기술적으로는 타당해야 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Run ``./genpepindex.py`` and ``./pep2html.py &lt;PEP Number&gt;`` to ensure they
  are generated without errors. If either triggers errors, then the web site
  will not be updated to reflect the PEP changes.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T040413Z">
        <seg>* ``./genpepindex.py``\ 와 ``./pep2html.py &lt;PEP Number&gt;``\ 를 수행하여 오류
  없이 생성되는지 확인한다.  프로그램이 오류를 일으킨다면, 웹사이트에는
  해당 PEP의 수정사항이 반영되지 않을 것이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Send email back to the PEP author with next steps (post to
  python-list &amp; -dev).</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T040749Z">
        <seg>* PEP 저자에게 다음 단계와 함께 이메일을 보낸다(python-list 및 -dev에 게재).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Some annotations in the abstract base classes were incorrect
    specifications.  For example, set-to-set operations require
    *other* to be another instance of *Set* rather than just an
    *Iterable*.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T155916Z">
        <seg>* 추상 기본 클래스의 어노테이션 일부는 부정확한 명세를 갖고 있다.
    예를 들면, set-to-set 연산은 Set 객체를 필요로 하는데, 이는
    *Iterable*\ 이 아닌 *Set* 인스턴스를 얻기 위해서이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* The annotation ``seek(whence:int)`` exhibited a mix of
    over-specification and under-specification: *int* is too
    restrictive (anything with ``__index__`` would be allowed) and it
    is not restrictive enough (only the values 0, 1, and 2 are
    allowed).  Likewise, the annotation ``write(b: bytes)`` was also
    too restrictive (anything supporting the buffer protocol would be
    allowed).</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T155657Z">
        <seg>* ``seek(whence:int)``\ 란 어노테이션은 명세가 특정 부분에서는 제약이
    심하고, 혹은 그렇지 않을 때도 있음을 보여준다: int는 지나치게
    한정적이며(``__index__``\ 가 허용하는 모든 것이 허용된다), 동시에
    한정적이지 않기도 하다(0, 1, 2 값만 허용된다).  마찬가지로
    ``write(b: bytes)``\ 라는 어노테이션 또한 지나치게 한정적이다(버퍼
    프로토콜을 허용하는 모든 값을 지원한다).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* The first line of each fuction docstring should be a "signature
  line" that gives a brief synopsis of the arguments and return value.
  For example::</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T054723Z">
        <seg>* 각 함수 문서화 문자열의 첫 줄에는, 다음과 같이 간략한 개요와 반환
  값을 기술하는 "시그너쳐 행"이 오도록 해야 한다. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* The notation ``open(file:(str,bytes))`` was used for a value that
    could be either *bytes* or *str* rather than a 2-tuple containing
    a *str* value followed by a *bytes* value.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T155631Z">
        <seg>* ``open(file:(str,bytes))``\ 이란 어노테이션은 *str* 다음에 *bytes*
    값을 갖는 2개의 튜플을 나타내는 것이 아니라, *bytes* 혹은 *str*\ 을
    가질 수 있는 값에 쓰인다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* The observed function annotations were too ad-hoc and inconsistent
    to work with a coherent system of automatic type checking or
    argument validation.  Leaving these annotations in the code would
    have made it more difficult to make changes later so that
    automated utilities could be supported.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T160011Z">
        <seg>* 이와 같은 함수 어노테이션들은 자동 타입 검사나 인수의 검증을
    수행하는 시스템에서 사용하기에는 너무 주먹구구식이고 일관성이
    없었다. 이러한 어노테이션을 코드에 남겨두면 차후에 자동화된 유틸리티
    등을 작성하기 위해 코드를 수정할 때 어려움을 겪을 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* The return statement should *not* get redundant parentheses::</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T050134Z">
        <seg>* return 문에는 불필요한 괄호를 사용하지 *않는다.* ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* The title should accurately describe the content.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T024620Z">
        <seg>* 제목은 내용을 정확하게 기술하여야 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Unix-like software distributions (including systems like Mac OS X and
  Cygwin) should install the ``python2`` command into the default path
  whenever a version of the Python 2 interpreter is installed, and the same
  for ``python3`` and the Python 3 interpreter.
* When  invoked, ``python2`` should run some version of the Python 2
  interpreter, and ``python3`` should run some version of the Python 3
  interpreter.
* Similarly, the more general ``python`` command should be installed whenever
  any version of Python is installed and should invoke the same version of
  Python as either ``python2`` or ``python3``.
* For the time being, it is recommended that ``python`` should refer to
  ``python2`` (however, some distributions have already chosen otherwise; see
  the `Rationale`_ and `Migration Notes`_ below).
* The Python 2.x ``idle``, ``pydoc``, and ``python-config`` commands should
  likewise be available as ``idle2``, ``pydoc2``, and ``python2-config``,
  with the original commands invoking these versions by default, but possibly
  invoking the Python 3.x versions instead if configured to do so by the
  system administrator.
* In order to tolerate differences across platforms, all new code that needs
  to invoke the Python interpreter should not specify ``python``, but rather
  should specify either ``python2`` or ``python3`` (or the more specific
  ``python2.x`` and ``python3.x`` versions; see the `Migration Notes`_).
  This distinction should be made in shebangs, when invoking from a shell
  script, when invoking via the system() call, or when invoking in any other
  context.
* One exception to this is scripts that are deliberately written to be source
  compatible with both Python 2.x and 3.x. Such scripts may continue to use
  ``python`` on their shebang line without affecting their portability.
* When reinvoking the interpreter from a Python script, querying
  ``sys.executable`` to avoid hardcoded assumptions regarding the
  interpreter location remains the preferred approach.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T054752Z">
        <seg>* Unix-like software distributions (including systems like Mac OS X and
  Cygwin) should install the ``python2`` command into the default path
  whenever a version of the Python 2 interpreter is installed, and the same
  for ``python3`` and the Python 3 interpreter.
* When  invoked, ``python2`` should run some version of the Python 2
  interpreter, and ``python3`` should run some version of the Python 3
  interpreter.
* Similarly, the more general ``python`` command should be installed whenever
  any version of Python is installed and should invoke the same version of
  Python as either ``python2`` or ``python3``.
* For the time being, it is recommended that ``python`` should refer to
  ``python2`` (however, some distributions have already chosen otherwise; see
  the `근거`_ and `Migration Notes`_ below).
* The Python 2.x ``idle``, ``pydoc``, and ``python-config`` commands should
  likewise be available as ``idle2``, ``pydoc2``, and ``python2-config``,
  with the original commands invoking these versions by default, but possibly
  invoking the Python 3.x versions instead if configured to do so by the
  system administrator.
* In order to tolerate differences across platforms, all new code that needs
  to invoke the Python interpreter should not specify ``python``, but rather
  should specify either ``python2`` or ``python3`` (or the more specific
  ``python2.x`` and ``python3.x`` versions; see the `Migration Notes`_).
  This distinction should be made in shebangs, when invoking from a shell
  script, when invoking via the system() call, or when invoking in any other
  context.
* One exception to this is scripts that are deliberately written to be source
  compatible with both Python 2.x and 3.x. Such scripts may continue to use
  ``python`` on their shebang line without affecting their portability.
* When reinvoking the interpreter from a Python script, querying
  ``sys.executable`` to avoid hardcoded assumptions regarding the
  interpreter location remains the preferred approach.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Use 4-space indents and no tabs at all.</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T044254Z">
        <seg>* 공백 네 개의 들여쓰기를 사용하고 탭은 사용하지 않는다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Use ANSI/ISO standard C (the 1989 version of the standard).  This
  means (amongst many other things) that all declarations must be at
  the top of a block (not necessarily at the top of function).</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T044516Z">
        <seg>* ANSI/ISO 표준 C(표준 1989 버전)를 사용하라.  이는 모든 선언이 최상위
  블록에 위치하여야 함을 의미한다(함수의 상단일 필요는 없다).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Use a ``Py`` prefix for public functions; never for static
  functions.  The ``Py_`` prefix is reserved for global service
  routines like ``Py_FatalError``; specific groups of routines
  (e.g. specific object type APIs) use a longer prefix,
  e.g. ``PyString_`` for string functions.</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T053832Z">
        <seg>* 퍼블릭 함수에 대해서는 ``Py``\ 를 앞에 붙이고, 정적 함수에
  대해서는 절대 그렇게 하지 않는다.  ``Py_``\ 는
  ``Py_FatalError``\ 와 같은 전역 서비스 루틴을 위한 것이다.
  특정한 루틴 그룹(특정한 개체 유형 API 등)은 보다 긴 접두어를
  사용하는데, 문자열 함수에 ``PyString_``\ 을 붙이는 것을 예로
  들 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* Use the ``PyDoc_STR()`` or ``PyDoc_STRVAR()`` macro for docstrings
  to support building Python without docstrings (``./configure
  --without-doc-strings``).</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T054629Z">
        <seg>* ``PyDoc_STR()`` 또는 ``PyDoc_STRVAR()`` 매크로를 사용함으로써,
  문서화 문자열 없이 파이썬을 빌드(``./configure
  --without-doc-strings``)할 수 있도록 지원한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* When writing multi-line docstrings, be sure to always use backslash
  continuations, as in the example above, or string literal
  concatenation::</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T055014Z">
        <seg>* 여러 줄에 걸친 문서화 문자열을 작성할 때에는, 위와 같이 백슬래쉬를
  사용하여 연결하거나, 다음과 같이 문자열 리터럴 접속을 사용한다. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* When you break a long expression at a binary operator, the
  operator goes at the end of the previous line, e.g.::</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T053431Z">
        <seg>* 긴 행을 이항 연산자가 있는 곳에서 나눌 때는, 다음과 같이 윗줄의
  끝에 연산자가 오도록 한다. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* `Following Python's Development
  &lt;http://docs.python.org/devguide/communication.html&gt;`_</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T041518Z">
        <seg>* `Python 개발 따라잡기
  &lt;http://docs.python.org/devguide/communication.html&gt;`_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* `Frequently Asked Questions for Developers
  &lt;http://docs.python.org/devguide/faq.html&gt;`_</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T041500Z">
        <seg>* `개발자들을 위한 자주 묻는 질문
  &lt;http://docs.python.org/devguide/faq.html&gt;`_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* `Index of Python Enhancement Proposals &lt;http://www.python.org/dev/peps/&gt;`_</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T041544Z">
        <seg>* `Python 개선 제안 색인 &lt;http://www.python.org/dev/peps/&gt;`_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* `Python Developer's Guide &lt;http://docs.python.org/devguide/&gt;`_</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T041431Z">
        <seg>* `Python 개발자 안내서 &lt;http://docs.python.org/devguide/&gt;`_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>* ``[str]`` was ambiguous as to whether it represented a list of
    strings or a value that could be either *str* or *None*.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T155451Z">
        <seg>* ``[str]``\ 은 이 어노테이션이 문자열 리스트를 나타내는지, str 혹은
    None 타입의 값을 나타내는지 모호하다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>*Note: The Resolution header is required for Standards Track PEPs
only.  It contains a URL that should point to an email message or
other web resource where the pronouncement about the PEP is made.*</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130605T063416Z">
        <seg>*참고: Resolution 헤더는 표준 트랙 PEP에 한하여 필요하다.  PEP가
만들어진 것에 대하여 공식적으로 밝힌 이메일 주소 또는 다른 웹 자원을
가리키는 URL을 포함한다.*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Added some `References`_.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T060852Z">
        <seg>- Added some `참조`_.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Additionally, for all try/except clauses, limit the ``try`` clause
  to the absolute minimum amount of code necessary.  Again, this
  avoids masking bugs.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154923Z">
        <seg>- 또한, try/except 절을 사용할 때에는 ``try`` 절이 적용되는 코드의
  범위를 최소화해야 한다.  이는 버그가 겹치는 일을 막아준다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Always surround these binary operators with a single space on either
  side: assignment (``=``), augmented assignment (``+=``, ``-=``
  etc.), comparisons (``==``, ``&lt;``, ``&gt;``, ``!=``, ``&lt;&gt;``, ``&lt;=``,
  ``&gt;=``, ``in``, ``not in``, ``is``, ``is not``), Booleans (``and``,
  ``or``, ``not``).</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151558Z">
        <seg>- 항상 이진 연산자의 주위에는 한 개의 공백을 넣는다: 할당 (``=``),
  증감 할당 (``+=``, ``-=`` 등.), 비교 (``==``, ``&lt;``, ``&gt;``,
  ``!=``, ``&lt;&gt;``, ``&lt;=``, ``&gt;=``, ``in``, ``not in``, ``is``,
  ``is not``), 부울 연산 (``and``, ``or``, ``not``).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Clarified Abstract_, Motivation_, `Reference Implementation`_ and
  `Open Issues`_ based on the simultaneous concepts of ``Max`` and
  ``Min``.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T061010Z">
        <seg>- Clarified 초록_, Motivation_, `Reference Implementation`_ and
  `Open Issues`_ based on the simultaneous concepts of ``Max`` and
  ``Min``.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Code should be written in a way that does not disadvantage other
  implementations of Python (PyPy, Jython, IronPython, Cython, Psyco,
  and such).</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154307Z">
        <seg>- 파이썬 코드는 다른 파이썬 구현(PyPy, Jython, IronPython, Cython,
  Psyco 등)에서 손해를 보지 않는 방식으로 구현하여야 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Comparisons to singletons like None should always be done with
  ``is`` or ``is not``, never the equality operators.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154409Z">
        <seg>- None과 같은 싱글턴 객체에 대해 비교 연산을 할 때에는 항상 ``is``
  혹은 ``is not`` 키워드를 사용하며, 동등 비교 연산자를 사용해선 안된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Compound statements (multiple statements on the same line) are
  generally discouraged.</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130527T161432Z">
        <seg>- 복합 구문(Compound statements, 여러 구문이 한 줄에 있는 것)은
  일반적으로 권장되지 않는다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Context managers should be invoked through separate functions or methods
  whenever they do something other than acquire and release resources.
  For example:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154953Z">
        <seg>- 리소스의 점유/해제 외의 작업을 제외하고, 어떤 작업을 할 때든지
    별도의 함수/메서드를 통해 문맥(context) 관리자를 호출해야 한다.
    예를 들면:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Don't compare boolean values to True or False using ``==``. ::</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T155342Z">
        <seg>- ``==``\ 를 사용해서 True/False 값을 부울 값과 비교하지 않는다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Don't use spaces around the ``=`` sign when used to indicate a
  keyword argument or a default parameter value.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151622Z">
        <seg>- 키워드 인수 혹은 기본 매개변수 값을 나타내는 경우에는 ``=`` 기호
  주위에 공백을 넣지 않는다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Don't write string literals that rely on significant trailing
  whitespace.  Such trailing whitespace is visually indistinguishable
  and some editors (or more recently, reindent.py) will trim them.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T155327Z">
        <seg>- 공백 문자가 뒤에 따라오는 문자 상수를 사용하지 않는다.  이렇게 뒤에
  붙은 공백 문자는 눈에 잘 띄지 않으며, 일부 편집기(혹은 최신의
  reindent.py)에서는 이러한 공백 문자를 제거한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- For one liner docstrings, it's okay to keep the closing ``"""`` on
  the same line.</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130527T162249Z">
        <seg>- 한 줄 짜리 docstring의 경우에는 같은 줄에서 ``"""``\ 를 닫아도 된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- For sequences, (strings, lists, tuples), use the fact that empty
  sequences are false. ::</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T155300Z">
        <seg>- 배열 형태의 타입(문자열, 리스트, 튜플)은 그 내용이 비어있을 때
  false를 반환한다는 사실을 활용한다. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- For simple public data attributes, it is best to expose just the
  attribute name, without complicated accessor/mutator methods.  Keep
  in mind that Python provides an easy path to future enhancement,
  should you find that a simple data attribute needs to grow
  functional behavior.  In that case, use properties to hide
  functional implementation behind simple data attribute access
  syntax.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154020Z">
        <seg>- 간단한 public 데이터 어트리뷰트의 경우, 복잡한 접근자/변경자 메서드
  대신 어트리뷰트 이름을 직접 노출하는 방법이 가장 좋다.  파이썬은
  향후 개선에 대하여 가장 쉬운 방법을 제공하며, 기능이 늘어날 수록
  간단한 데이터 어트리뷰트가 필요하다는 것을 알아야 한다.  이런
  경우, 프로퍼티를 사용하여 실제 기능 구현을 숨기고 사용자는 간단한
  데이터 어트리뷰트에 접근하는 문법을 사용할 수 있도록 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- If operators with different priorities are used, consider adding
  whitespace around the operators with the lowest priority(ies). Use
  your own judgement; however, never use more than one space, and
  always have the same amount of whitespace on both sides of a binary
  operator.</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130527T161413Z">
        <seg>- 우선 순위가 서로 다른 연산자를 함께 사용할 경우, 우선 순위가 낮은
  연산자 주위에 공백을 넣을지 고려해보자.  하지만 이 경우에도 한 개를
  초과하는 공백 문자를 사용하면 안 되며, 이진 연산자의 양쪽을 똑같은
  방식으로 기술하도록 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- If your class is intended to be subclassed, and you have attributes
  that you do not want subclasses to use, consider naming them with
  double leading underscores and no trailing underscores.  This
  invokes Python's name mangling algorithm, where the name of the
  class is mangled into the attribute name.  This helps avoid
  attribute name collisions should subclasses inadvertently contain
  attributes with the same name.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154109Z">
        <seg>- 부모 클래스를 디자인하면서 특정 어트리뷰트가 상속되지 않도록 하고
  싶다면, 이들 어트리뷰트의 이름 앞에 두 개의 언더스코어를 붙이는 것을
  고려해보자.  이렇게 하면 파이썬의 네임 맹글링 기능을 사용하게
  되며, 어트리뷰트 이름 앞에 클래스의 이름이 맹글링된다. 이 기능은
  자식 클래스가 우연히 동일한 어트리뷰트 이름을 사용했을 때 어트리뷰트
  이름 충돌이 일어나는 것을 막아준다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- If your public attribute name collides with a reserved keyword,
  append a single trailing underscore to your attribute name.  This is
  preferable to an abbreviation or corrupted spelling.  (However,
  notwithstanding this rule, 'cls' is the preferred spelling for any
  variable or argument which is known to be a class, especially the
  first argument to a class method.)</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153948Z">
        <seg>- public 어트리뷰트의 이름이 예약어와 충돌할 경우, 어트리뷰트 이름의
  끝에 언더스코어 문자 하나를 추가한다.  약어나 틀린 맞춤법을 사용하
  는 대신 이 방식을 권장한다.  (이 규칙과는 상관 없이, 'cls'는 변수
  혹은 인수에서 클래스를 나타내는데 적절한 단어이며, 특히 클래스 메
  서드의 첫 번째 인수로 쓰인다.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Immediately before a comma, semicolon, or colon::</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151306Z">
        <seg>- 콤마, 세미콜론, 콜론의 이전 위치::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Immediately before the open parenthesis that starts an indexing or
  slicing::</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151413Z">
        <seg>- 인덱싱 혹은 슬라이싱이 시작되는 괄호의 바로 이전 위치::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Immediately before the open parenthesis that starts the argument
  list of a function call::</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151359Z">
        <seg>- 함수 호출시 인수 목록이 시작되는 괄호의 바로 이전 위치::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Immediately inside parentheses, brackets or braces. ::</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151312Z">
        <seg>- 괄호, 중괄호, 대괄호 내부에 연결되는 부분::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Imports are always put at the top of the file, just after any module
  comments and docstrings, and before module globals and constants.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150914Z">
        <seg>- 임포트 구문은 항상 파일의 최상단에 위치해야 하며, 모듈의 주석문과
  docstring의 바로 다음, 그리고 모듈의 전역 변수와 상수 바로 이전에
  위치한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Imports should usually be on separate lines, e.g.::</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130527T161151Z">
        <seg>- 임포트는 보통 행으로 구분되어야 한다. 예를 들면, ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- More than one space around an assignment (or other) operator to
  align it with another.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151433Z">
        <seg>- 할당(혹은 기타 다른) 연산자 주변에 한 개를 초과하는 공백 문자가
  있는 경우.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Object type comparisons should always use isinstance() instead of
  comparing types directly. ::</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T155211Z">
        <seg>- 객체 타입 비교 시, 타입을 직접 비교하는 대신 항상 isinstance()를
  사용한다. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- PEP 257 describes good docstring conventions.  Note that most
  importantly, the ``"""`` that ends a multiline docstring should be
  on a line by itself, and preferably preceded by a blank line, e.g.::</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T152353Z">
        <seg>- PEP 257은 좋은 docstring 작성 규칙에 대해 기술하고 있다.  ``"""``
  영역이 끝나는 부분에서는 한 줄 전체에 ``"""`` 문자를 넣고, 바로 위의
  한 줄을 빈 줄로 두어야 한다. 다음 예를 보자. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Public attributes should have no leading underscores.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153931Z">
        <seg>- public 어트리뷰트는 언더스코어 문자로 시작해선 안된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Relative imports for intra-package imports are highly discouraged.
  Always use the absolute package path for all imports.  Even now that
  PEP 328 is fully implemented in Python 2.5, its style of explicit
  relative imports is actively discouraged; absolute imports are more
  portable and usually more readable.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151058Z">
        <seg>- 인접(relative) 경로를 사용하여 내부 패키지를 임포트하지 않도록 한다.
  항상 절대 패키지 경로를 사용하여 임포트를 하도록 하자.  현재
  파이썬 2.5에 PEP 328이 완전히 구현되어 있으나, 명시적 인접 임포트
  (explicit relative import)는 여전히 권장되지 않는다;  절대 임포트
  (역주: 절대 경로를 사용한 임포트)는 이식성이 높으며, 일반적으로
  읽기 더 쉽다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- The Python standard library will not use function annotations as
  that would result in a premature commitment to a particular
  annotation style.  Instead, the annotations are left for users to
  discover and experiment with useful annotation styles.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T155425Z">
        <seg>- 파이썬 표준 라이브러리는 특정 어노테이션 스타일에 얽매인 함수
  어노테이션을 사용하지 않는다.  그 대신에, 사용자로 하여금 유용한
  어노테이션 스타일을 직접 발견하고 실험해 볼 수 있도록 하고 있다.
  (역주: 여기에서의 함수 어노테이션은 다른 프로그래밍 언어의 함수
  프로토타입과 비슷하게 함수에 대한 정의를 말한다. PEP 3107을 참고)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Use ``''.startswith()`` and ``''.endswith()`` instead of string
  slicing to check for prefixes or suffixes.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T155123Z">
        <seg>- 문자열의 접두사/접미사를 확인하기 위해 문자열을 직접 자르는 대신,
  ``''.startswith()``\ 와 ``''.endswith()``\ 를 사용한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Use class-based exceptions.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154534Z">
        <seg>- 클래스 기반의 예외를 사용한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Use string methods instead of the string module.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T155044Z">
        <seg>- string 모듈 대신 문자열 관련 메서드를 사용한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- When catching exceptions, mention specific exceptions whenever
  possible instead of using a bare ``except:`` clause.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154720Z">
        <seg>- 예외를 처리할(catch) 때에는 범용적인 ``except:`` 절 대신, 처리할
  특정한 예외를 명시하도록 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- When implementing ordering operations with rich comparisons, it is
  best to implement all six operations (``__eq__``, ``__ne__``,
  ``__lt__``, ``__le__``, ``__gt__``, ``__ge__``) rather than relying
  on other code to only exercise a particular comparison.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154445Z">
        <seg>- 향상된 비교 연산자를 사용해 정렬 기능을 구현할 경우, 특정한 비교
  연산만 구현하는 것 보다는 여섯 개의 연산(``__eq__``,
  ``__ne__``, ``__lt__``, ``__le__``, ``__gt__``, ``__ge__``)을 모두
  구현하는 것이 최선의 방법이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- When importing a class from a class-containing module, it's usually
  okay to spell this::</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130527T161251Z">
        <seg>- 클래스를 포함하고 있는 모듈에서 클래스를 임포트할 때, 보통은 다음과
  같이 기술한다. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- When raising an exception, use ``raise ValueError('message')``
  instead of the older form ``raise ValueError, 'message'``.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154639Z">
        <seg>- 예외를 발생시키려면 `raise ValueError('message')`` 구문을 사용한다.
  예전의 ``raise ValueError, 'message'`` 구문은 더 이상 사용하지
  않는다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- While sometimes it's okay to put an if/for/while with a small body
  on the same line, never do this for multi-clause statements.  Also
  avoid folding such long lines!</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151716Z">
        <seg>- 짧은 if/for/while 구문을 한 줄에 넣는 것은 괜찮지만, 여러 절을 가진
  구문은 절대 한 줄에 기술하지 않는다.  또한 한 줄에 여러 구문을
  기술하면서 줄바꿈을 하는 것도 피해야 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- Write docstrings for all public modules, functions, classes, and
  methods.  Docstrings are not necessary for non-public methods, but
  you should have a comment that describes what the method does.  This
  comment should appear after the ``def`` line.</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130527T162227Z">
        <seg>- public으로 정의된 모든 모듈, 함수, 클래스, 메서드에 대해 docstring을
  작성한다.  public으로 정의되지 않은 메서드에는 docstring을 작성할
  필요가 없다.  하지만 해당 메서드가 무슨 일을 하는지 설명하는 주석은
  달아야 한다.  이러한 주석은 ``def``\ 가 있는 행 바로 다음 행에
  작성한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- ``__double_leading_and_trailing_underscore__``: "magic" objects or
  attributes that live in user-controlled namespaces.
  E.g. ``__init__``, ``__import__`` or ``__file__``.  Never invent
  such names; only use them as documented.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T152948Z">
        <seg>- ``__double_leading_and_trailing_underscore__``: 사용자가 관리하는
  네임스페이스 내에 있는 "마법(magic)" 객체.  ``__init__``,
  ``__import__``, ``__file__`` 등이 그 예이다.  이러한 이름을 정의해서
  사용하면 안 되며, 이미 문서화되어 있는 항목들만 사용해야 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- ``__double_leading_underscore``: when naming a class attribute,
  invokes name mangling (inside class FooBar, ``__boo`` becomes
  ``_FooBar__boo``; see below).</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130527T162346Z">
        <seg>- ``__double_leading_underscore``: 클래스 어트리뷰트의 이름을 지으면
  네임 맹글링(name mangling)이 발생한다 (FooBar 클래스 내부에
  ``__boo``를 선언하면 이는 ``_FooBar__boo``\ 가 된다; 아래 내용을
  참고하라).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- ``_single_leading_underscore``: weak "internal use" indicator.
  E.g. ``from M import *`` does not import objects whose name starts
  with an underscore.</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130527T162317Z">
        <seg>- ``_single_leading_underscore``: "내부에서 사용한다"는 것을 의미.
  예를 들면, ``from M import *``\ 은 언더스코어로 시작하는 객체를
  임포트하지 않는다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- ``b`` (single lowercase letter)
- ``B`` (single uppercase letter)
- ``lowercase``
- ``lower_case_with_underscores``
- ``UPPERCASE``
- ``UPPER_CASE_WITH_UNDERSCORES``
- ``CapitalizedWords`` (or CapWords, or CamelCase -- so named because
  of the bumpy look of its letters [3]_).  This is also sometimes known
  as StudlyCaps.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T152703Z">
        <seg>- ``b`` (한 개의 소문자)
- ``B`` (한 개의 대문자)
- ``lowercase``
- ``lower_case_with_underscores``
- ``UPPERCASE``
- ``UPPER_CASE_WITH_UNDERSCORES``
- ``CapitalizedWords`` (CapWords 혹은 CamelCase -- CamelCase라는 이름은
  글자가 툭 튀어나온 모양 때문에 붙은 이름이다 [3]_).  간혹
  StudlyCaps이라고도 불린다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>- ``single_trailing_underscore_``: used by convention to avoid
  conflicts with Python keyword, e.g. ::</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T152854Z">
        <seg>- ``single_trailing_underscore_``: 파이썬 키워드와의 충돌을 방지하기
  위해 쓰인다.  예::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>-Barry Warsaw, PEP editor</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T163830Z">
        <seg>-Barry Warsaw, PEP 편집자</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.. [1] PEP 1, PEP Purpose and Guidelines, Warsaw, Hylton
   (http://www.python.org/dev/peps/pep-0001)</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T163609Z">
        <seg>.. [1] PEP 1, PEP 목적 및 안내, Warsaw, Hylton
   (http://www.python.org/dev/peps/pep-0001)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.. [1] PEP 7, Style Guide for C Code, van Rossum</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T160053Z">
        <seg>.. [1] PEP 7, C 코드 스타일 가이드, van Rossum</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.. [1] PEP 8, "Style Guide for Python Code", van Rossum, Warsaw
       (http://www.python.org/dev/peps/pep-0008)</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T051809Z">
        <seg>.. [1] PEP 8, "파이썬 코드 스타일 안내", van Rossum, Warsaw
       (http://www.python.org/dev/peps/pep-0008)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.. [1] This historical record is available by the normal hg commands
   for retrieving older revisions, and can also be browsed via HTTP here:
   http://hg.python.org/peps/</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T042608Z">
        <seg>.. [1] 이 이력 레코드는 이전 리비전을 조회하는 보통의 hg 명령으로 얻어낼
   수 있으며, 다음 주소에서 HTTP를 통해 조회할 수 있다:
   http://hg.python.org/peps/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.. [2] Barry's GNU Mailman style guide
       http://barry.warsaw.us/software/STYLEGUIDE.txt</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T160106Z">
        <seg>.. [2] Barry의 GNU Mailman 스타일 가이드
       http://barry.warsaw.us/software/STYLEGUIDE.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.. [2] PEP 2, Procedure for Adding New Modules, Faassen
   (http://www.python.org/dev/peps/pep-0002)</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T041805Z">
        <seg>.. [2] PEP 2, 새로운 모듈을 추가하는 절차, Faassen
   (http://www.python.org/dev/peps/pep-0002)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.. [2] PEP 9, Sample Plaintext PEP Template, Warsaw
   (http://www.python.org/dev/peps/pep-0009)</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T163627Z">
        <seg>.. [2] PEP 9, 일반 텍스트 PEP 템플릿 견본, Warsaw
   (http://www.python.org/dev/peps/pep-0009)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.. [3] PEP 9, Sample Plaintext PEP Template, Warsaw
   (http://www.python.org/dev/peps/pep-0009)</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T041830Z">
        <seg>.. [3] PEP 9, 일반 텍스트 PEP 템플릿 견본, Warsaw
   (http://www.python.org/dev/peps/pep-0009)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.. [4] PEP 12, Sample reStructuredText PEP Template, Goodger, Warsaw
   (http://www.python.org/dev/peps/pep-0012)</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T041842Z">
        <seg>.. [4] PEP 12, reStructuredText PEP 템플릿 견본, Goodger, Warsaw
   (http://www.python.org/dev/peps/pep-0012)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.. [5] The script referred to here is pep2pyramid.py, the successor to
   pep2html.py, both of which live in the same directory in the hg
   repo as the PEPs themselves.  Try ``pep2html.py --help`` for
   details.  The URL for viewing PEPs on the web is
   http://www.python.org/dev/peps/.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T045230Z">
        <seg>.. [5] 여기서 참조하는 스크립트는 pep2html.py를 계승하는 pep2pyramid.py로,
   hg 저장소에서 PEP 자체가 있는 곳과 같은 디렉토리에 있다.  자세한 내용을
   보려면 ``pep2html.py --help``\ 를 실행한다.  웹에서 PEP를 볼 수 있는
   URL은 http://www.python.org/dev/peps/\ 이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.. _Open Publication License: http://www.opencontent.org/openpub/</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T042318Z">
        <seg>.. _공개 출판 라이선스: http://www.opencontent.org/openpub/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.. _PEP repository: http://hg.python.org/peps</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T042536Z">
        <seg>.. _PEP 저장소: http://hg.python.org/peps</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>.. _issue tracker:
   http://bugs.python.org/</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T042243Z">
        <seg>.. _이슈 트래커:
   http://bugs.python.org/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1. A **Standards Track** PEP describes a new feature or implementation
   for Python. It may also describe an interoperability standard that will
   be supported outside the standard library for current Python versions
   before a subsequent PEP adds standard library support in a future
   version.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T124512Z">
        <seg>1. **표준 트랙** PEP는 파이썬의 새로운 기능이나 구현을 기술한다.  그것은 또한
   차후의 PEP가 앞으로의 파이썬 버전에서 지원할 표준 라이브러리 지원을
   추가하기에 앞서, 현재의 파이썬 버전을 위한 표준 라이브러리의 외부로부터
   지원될 상호운용성 표준을 기술할 수도 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1. If the exception handler will be printing out or logging the
     traceback; at least the user will be aware that an error has
     occurred.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154826Z">
        <seg>1. 예외 핸들러가 역추적(traceback) 결과를 출력하거나 로그를 남겨야
     할 경우. 사용하가 최소한 에러가 일어났음을 인지할 수 있게 된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1. Preamble -- RFC 822 style headers containing meta-data about the
   PEP, including the PEP number, a short descriptive title (limited
   to a maximum of 44 characters), the names, and optionally the
   contact info for each author, etc.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125525Z">
        <seg>1. 서론 -- PEP 번호, 짧고 설명적인 제목(최대 44 글자로 제한), 이름, 각
   저자에 대한 연락 정보 등의 PEP에 대한 메타 정보를 담은 RFC 822 스타일의
   머리말.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1. When applying the rule would make the code less readable, even for
   someone who is used to reading code that follows the rules.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T145924Z">
        <seg>1. 기존의 규칙을 따르는 코드를 읽는데 익숙한 사람조차 해당 규칙을 적용한
   코드의 가독성이 나빠진다고 판단할 경우.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>1. standard library imports
  2. related third party imports
  3. local application/library specific imports</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150957Z">
        <seg>1. 표준 라이브러리
  2. 관련이 있는 서드파티 라이브러리
  3. 로컬 어플리케이션/자체 라이브러리</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2. Abstract -- a short (~200 word) description of the technical issue
   being addressed.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125540Z">
        <seg>2. 초록 -- 기술적인 이슈에 대한 짧은(200 단어 이내) 설명을 제시.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2. An **Informational** PEP describes a Python design issue, or
   provides general guidelines or information to the Python community,
   but does not propose a new feature.  Informational PEPs do not
   necessarily represent a Python community consensus or
   recommendation, so users and implementers are free to ignore
   Informational PEPs or follow their advice.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T124640Z">
        <seg>2. **정보** PEP는 파이썬의 설계 상의 문제나 일반적인 지침 또는 파이썬 
   커뮤니티를 위한 정보를 기술하지만, 새로운 기능을 제안하지는 않는다.
   정보 PEP가 반드시 파이썬 커뮤니티의 합의나 권고를 나타내는 것은 아니며,
   따라서 사용자 및 구현자가 정보 PEP를 무시할 지 혹은 그 조언을 따를 지는
   자유이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2. If the code needs to do some cleanup work, but then lets the
     exception propagate upwards with ``raise``.  ``try...finally``
     can be a better way to handle this case.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154911Z">
        <seg>2. 코드에서 일종의 정리 작업을 수행한 다음, ``raise`` 명령을 사용해
     해당 예외를 상위 단계로 계속 올려보내려 할 경우. 이 경우에는
     ``try...finally`` 구문을 사용하는 것이 더 나은 방법일 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>2. To be consistent with surrounding code that also breaks it (maybe
   for historic reasons) -- although this is also an opportunity to
   clean up someone else's mess (in true XP style).</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T145943Z">
        <seg>2. (아마 기존 관습 때문에) 일관성을 잃은 기존 코드를 갈아엎어서 코드의
   일관성을 확립하고자 하는 경우.  이는 기존 코드의 지저분한 부분들을
   (진정한 XP 스타일로) 정리할 수 있는 기회이기도 하다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3. A **Process** PEP describes a process surrounding Python, or
   proposes a change to (or an event in) a process.  Process PEPs are
   like Standards Track PEPs but apply to areas other than the Python
   language itself.  They may propose an implementation, but not to
   Python's codebase; they often require community consensus; unlike
   Informational PEPs, they are more than recommendations, and users
   are typically not free to ignore them.  Examples include
   procedures, guidelines, changes to the decision-making process, and
   changes to the tools or environment used in Python development.
   Any meta-PEP is also considered a Process PEP.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T124935Z">
        <seg>3. **프로세스** PEP는 파이썬을 둘러싼 프로세스 또는 프로세스(또는 프로세스
   내의 이벤트)의 변경을 기술한다.  프로세스 PEP들은 표준 트랙 PEP와 비슷하지만
   파이썬 언어 자체가 아닌 영역에 적용된다.  구현에 대하여 제안할 수도 있지만,
   파이썬의 코드 기반에 대한 것이 아니다.  그것들은 종종 커뮤니티의 합의를
   필요로 하기 때문이다.  정보 PEP와 달리, 그것들은 권고 이상이며 사용자가
   쉽게 무시할 수 없는 것들이다.  절차, 안내, 의사결정 프로세스의 변경 및
   파이썬 개발에 사용되는 도구나 환경의 변화를 예로 들 수 있다.  메타 PEP
   역시 프로세스 PEP로 간주한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>3. Copyright/public domain -- Each PEP must either be explicitly
   labeled as placed in the public domain (see this PEP as an
   example) or licensed under the `Open Publication License`_.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T042329Z">
        <seg>3. 저작권/공개 도메인 -- 각 PEP는 공개 도메인(이 PEP가 그 예이다) 또는
   `공개 출판 라이선스`_\ 에 의거하여 라이선스됨을 명시하여야 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>4. Specification -- The technical specification should describe the
   syntax and semantics of any new language feature.  The
   specification should be detailed enough to allow competing,
   interoperable implementations for at least the current major Python
   platforms (CPython, Jython, IronPython, PyPy).</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125600Z">
        <seg>4. 명세 -- 기술적인 명세는 새로운 언어 기능에 대한 구문(syntax)과 의미
   (semantics)를 기술한다.  명세는 최소한 현재의 주요한 파이썬 플랫폼(CPython,
   Jython, IronPython, PyPy)을 위한 경쟁적이고 상호운용 가능한 구현을 하기에
   충분할 만큼 자세하여야 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>5. Motivation -- The motivation is critical for PEPs that want to
   change the Python language.  It should clearly explain why the
   existing language specification is inadequate to address the
   problem that the PEP solves.  PEP submissions without sufficient
   motivation may be rejected outright.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125609Z">
        <seg>5. 동기부여 -- 파이썬 언어를 바꾸고자 하는 PEP에 있어서 동기가 중요하다.
   PEP가 해결하고자하는 문제를 해결하기에 기존의 언어 명세가 불충분한 이유를
   명확하게 설명하여야 한다.  충분한 동기 부여가 되지 않는 PEP 제출은 즉시
   거부할 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>6. Rationale -- The rationale fleshes out the specification by
   describing what motivated the design and why particular design
   decisions were made.  It should describe alternate designs that
   were considered and related work, e.g. how the feature is supported
   in other languages.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125620Z">
        <seg>6. 근거 -- 특정 디자인을 채택한 동기와 이유를 기술한다. 대체 가능한 다른
   디자인에 대한 검토 결과와 함께, 다른 언어에서는 그 기능을 어떻게
   지원하는지와 같은 관련 작업을 기술한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>7. Backwards Compatibility -- All PEPs that introduce backwards
   incompatibilities must include a section describing these
   incompatibilities and their severity.  The PEP must explain how the
   author proposes to deal with these incompatibilities.  PEP
   submissions without a sufficient backwards compatibility treatise
   may be rejected outright.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125648Z">
        <seg>7. 하위 호환성 -- 이전 버전과 호환되지 않는 모든 PEP는 이러한 비호환성과
   심각성을 기술하는 섹션을 포함하여야 한다.  PEP는 이러한 비호환성을 어떻게
   처리할 것인지에 대한 저자의 제안을 반드시 설명하여야 한다. 하위 호환성에
   대한 적절한 논문을 갖추지 않은 PEP는 즉시 거부된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>8. Reference Implementation -- The reference implementation must be
   completed before any PEP is given status "Final", but it need not
   be completed before the PEP is accepted.  While there is merit
   to the approach of reaching consensus on the specification and
   rationale before writing code, the principle of "rough consensus
   and running code" is still useful when it comes to resolving many
   discussions of API details.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125659Z">
        <seg>8. 참조 구현 -- PEP가 "최종" 상태를 얻기 전에 참조 구현이 반드시 완성되어야
   하지만, PEP가 수용되기 전에 반드시 완성되어야 하는 것은 아니다.  코드를
   작성하기 전에 명세 및 근거에 대한 합의에 도달하는 데에 이점이 있기는
   하지만, API의 세부사항에 대한 많은 논의를 해결하기 위한 "거친 합의와
   실행되는 코드"의 원칙은 여전히 유효하다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A Foolish Consistency is the Hobgoblin of Little Minds
======================================================</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T145802Z">
        <seg>멍청하게 일관성을 고집하는 것은 소인배의 발상이다
=================================================</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A PEP can also be "Rejected".  Perhaps after all is said and done it
was not a good idea.  It is still important to have a record of this
fact. The "Withdrawn" status is similar - it means that the PEP author
themselves has decided that the PEP is actually a bad idea, or has
accepted that a competing proposal is a better alternative.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125407Z">
        <seg>PEP는 "거부(Rejected)"될 수도 있다.  논의 끝에 좋지 못한 아이디어라고
판명되었기 때문일 수 있다.  이 사실에 대한 기록을 갖는 것이 중요하다. 
"철회(Withdrawn)" 상태도 이와 비슷하게, PEP 저자가 그 PEP에 대하여 좋지
못한 아이디어라고 생각하거나 경쟁 관계의 다른 제안이 더 나은 대안임을 받아들인
것을 의미한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A PEP can also be assigned status "Deferred".  The PEP author or an
editor can assign the PEP this status when no progress is being made
on the PEP.  Once a PEP is deferred, a PEP editor can re-assign it
to draft status.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125358Z">
        <seg>PEP에는 "지연(Deferred)" 상태를 할당할 수도 있다.  PEP에 대하여 아무 진전이
없을 때 PEP 저자 또는 편집자가 이 상태를 부여할 수 있다.  PEP가 일단 지연되면,
PEP 편집자는 그것을 초안 상태로 되돌릴  수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A PEP editor must subscribe to the &lt;peps@python.org&gt; list.  All
correspondence related to PEP administration should be sent (or forwarded) to
&lt;peps@python.org&gt; (but please do not cross-post!).</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T024146Z">
        <seg>PEP 편집자는 &lt;peps@python.org&gt; 리스트를 구독해야 한다.  PEP 관리에 관련된
모든 내용은 &lt;peps@python.org&gt;에 작성 또는 전달한다(엇갈리게 게재하지
말아달라!).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A bare ``except:`` clause will catch SystemExit and
  KeyboardInterrupt exceptions, making it harder to interrupt a
  program with Control-C, and can disguise other problems.  If you
  want to catch all exceptions that signal program errors, use
  ``except Exception:`` (bare except is equivalent to ``except
  BaseException:``).</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154756Z">
        <seg>처리할 예외가 지정되지 않은 ``except:`` 절은 SystemExit,
  KeyboardInterrupt 예외를 처리하기 때문에 컨트롤-C를 눌러 프로그램을
  인터럽트할 수 없게 만드는 등 여러 문제를 일으킬 소지가 있다. 만약
  프로그램 에러의 징후를 알리는 모든 예외를 처리하고 싶다면
  ``except Exception:``를 사용하도록 하자(처리할 예외가 지정되지 않은
  except 절은 ``except BaseException:`` 절과 동일하다).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A good rule of thumb is to limit use of bare 'except' clauses to two
  cases:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154812Z">
        <seg>예외가 지정되지 않은 'except' 절을 사용해야 하는 적절한 경우는 다음과
  같다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A style guide is about consistency.  Consistency with this style guide
is important.  Consistency within a project is more important.
Consistency within one module or function is most important.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T145912Z">
        <seg>스타일 가이드는 일관성을 다룬다.  이 스타일 가이드에서 다루는 일관성은
중요한 내용이다.  프로젝트에서의 일관성은 중요하지만, 특정한 모듈
혹은 함수 내에서의 일관성은 정말 중요하다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Abstract</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T130250Z">
        <seg>초록</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Abstract
--------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T130712Z">
        <seg>초록
----</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Abstract
========</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T131205Z">
        <seg>초록
====</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Additional References</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170921Z">
        <seg>추가적인 참조</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Advantages</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170332Z">
        <seg>장점</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After a PEP number has been assigned, a draft PEP may be discussed further on
python-ideas (getting a PEP number assigned early can be useful for ease of
reference, especially when multiple draft PEPs are being considered at the
same time). Eventually, all Standards Track PEPs must  be sent to the
`python-dev list &lt;mailto:python-dev@python.org&gt;`__ for review as described
in the next section.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125229Z">
        <seg>PEP 번호가 할당되면, PEP 초안이 python-ideas에서 논의될 것이다(PEP 번호를
빨리 할당받는 것이 쉽게 찾는 데에 도움이 된다.  동시에 여러 개의 PEP 초안이
검토 중일 때 특히 그러하다). 결국, 모든 표준 트랙 PEP는 `python-dev 리스트
&lt;mailto:python-dev@python.org&gt;`__\ 로 보내어져서 다음 섹션에서 기술하는
바와 같이 검토된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Almost without exception, class names use the CapWords convention.
Classes for internal use have a leading underscore in addition.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153156Z">
        <seg>클래스 이름은 예외 없이 CapWords 규칙을 따른다.  또한 내부에서 사용하는
클래스는 앞에 언더스코어 문자 하나를 붙인다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, beware of writing ``if x`` when you really mean ``if x is not
  None`` -- e.g. when testing whether a variable or argument that
  defaults to None was set to some other value.  The other value might
  have a type (such as a container) that could be false in a boolean
  context!</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130527T162443Z">
        <seg>또한, ``if x is not None``\ 의 의미로 ``if x``\ 를 사용하는데 주의해야
  한다 -- 기본값이 None인 변수나 인수에 무언가 값이 지정되었는지를
  검사할 경우를 예로 들 수 있다.  이 값이 다른 객체를 포함하는 타입
  (컨테이너의 경우)일 수도 있으며, 그럴 경우 boolean으로 해석되어
  false를 반환할 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternative Approaches</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165909Z">
        <seg>다른 접근 방법</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Alternatives</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165609Z">
        <seg>대안</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Always decide whether a class's methods and instance variables
(collectively: "attributes") should be public or non-public.  If in
doubt, choose non-public; it's easier to make it public later than to
make a public attribute non-public.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153822Z">
        <seg>항상 클래스의 메서드와 인스턴스 변수(둘을 합쳐 "어트리뷰트")가
public인지 public이 아닌지를 결정해야 한다.  결정이 어려울 경우 비
public으로 정의한다.  비 public 어트리뷰트를 public으로 변경하는 것이
그 반대의 경우보다 쉽다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Always include a blank line between the signature line and the text
  of the description.</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T054756Z">
        <seg>시그너쳐 행과 설명 텍스트 사이에는 항상 한 줄을 띄운다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Always use ``cls`` for the first argument to class methods.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153415Z">
        <seg>클래스 메서드의 첫 번째 인수에는 ``cls``\ 를 사용해야 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Always use ``self`` for the first argument to instance methods.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153359Z">
        <seg>인스턴스 메서드의 첫 번째 인수에는 ``self``\ 를 사용해야 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An inline comment is a comment on the same line as a statement.
Inline comments should be separated by at least two spaces from the
statement.  They should start with a # and a single space.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T152040Z">
        <seg>인라인 주석문은 코드와 동일한 행에 기술되는 주석문이다.  인라인 주석문은
코드에서 최소한 두 개 이상의 공백으로 분리되어 있어야 한다.  주석문은
# 문자와 한 개의 공백으로 시작해야 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Another category of attributes are those that are part of the
"subclass API" (often called "protected" in other languages).  Some
classes are designed to be inherited from, either to extend or modify
aspects of the class's behavior.  When designing such a class, take
care to make explicit decisions about which attributes are public,
which are part of the subclass API, and which are truly only to be
used by your base class.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153905Z">
        <seg>어트리뷰트의 또 다른 한 가지 유형으로 "서브클래스 API"의 일부를 들
수 있다 (다른 언어에서는 "protected"라고 표현하곤 한다).  클래스들
중 일부는 상속을 위한 부모 클래스로서 설계되며, 클래스의 행동을 구성하는
요소들을 확장하거나 변경할 수 있다.  이러한 클래스를 설계할 때
어떤 어트리뷰트가 public이 될지, 서브클래스 API의 일부가 될지, 기본
클래스에서만 쓰일지에 대해 명확한 결정을 내리는데 신경써야 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As updates are necessary, the PEP author can check in new versions if they
(or a collaborating developer) have hg push privileges, or else they can
email new PEP versions to the PEP editors for publication.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125218Z">
        <seg>업데이트가 성공적이면, PEP 저자는 hg push 권한을 가지고 있는 경우 직접(또는
동료 개발자를 통해) 새로운 버전을 체크인할 수도 있고, 새로운 PEP 버전을 PEP
편집자에게 이메일로 보내어 출판하도록 할 수도 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At the same time, removing a module from the distribution is
    difficult, as it is not known in general whether anybody is still
    using it.  This PEP defines a procedure for removing modules from
    the standard Python library.  Usage of a module may be
    `deprecated', which means that it may be removed from a future
    Python release.  The rationale for deprecating a module is also
    collected in this PEP.  If the rationale turns out faulty, the
    module may become `undeprecated'.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T063344Z">
        <seg>한편, 배포본에서 모듈을 제거하는 것은 어려운데, 이는 누군가가 여전히
    그것을 사용하고 있을지도 모르기 때문이다.  이 PEP는 표준 파이썬
    라이브러리로부터 모듈을 제거하는 절차를 정의한다.  모듈의 사용은
    `금지(deprecated)'될 수 있는데, 이는 미래의 파이썬 릴리스에서
    그것이 제거될 수 있음을 의미한다.  모듈을 금지하는 근거도 역시
    이 PEP에 수집하였다.  근거가 틀린 것으로 판명되면, 모듈은 `금지
    해제(undeprecated)'될 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Auxiliary Files
===============</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T005626Z">
        <seg>보조적인 파일들
===============</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Avoid extraneous whitespace in the following situations:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151242Z">
        <seg>다음과 같은 상황에서는 여분의 공백 문자를 사용하지 않는다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>BDFL Pronouncements</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170758Z">
        <seg>BDFL 가라사대</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Background</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165555Z">
        <seg>배경</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Backward Compatibility</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170642Z">
        <seg>하위 호환성</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Backwards compatibility</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T131659Z">
        <seg>하위 호환성</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Batteries Included Philosophy</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165024Z">
        <seg>배터리 포함의 철학</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Beautiful is better than ugly.
    Explicit is better than implicit.
    Simple is better than complex.
    Complex is better than complicated.
    Flat is better than nested.
    Sparse is better than dense.
    Readability counts.
    Special cases aren't special enough to break the rules.
    Although practicality beats purity.
    Errors should never pass silently.
    Unless explicitly silenced.
    In the face of ambiguity, refuse the temptation to guess.
    There should be one-- and preferably only one --obvious way to do it.
    Although that way may not be obvious at first unless you're Dutch.
    Now is better than never.
    Although never is often better than *right* now.
    If the implementation is hard to explain, it's a bad idea.
    If the implementation is easy to explain, it may be a good idea.
    Namespaces are one honking great idea -- let's do more of those!</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T163002Z">
        <seg>아름다움이 추함보다 좋다.
    명시가 암시보다 좋다.
    단순함이 복잡함보다 좋다.
    복잡함이 꼬인 것보다 좋다.
    수평이 계층보다 좋다.
    여유로운 것이 밀집한 것보다 좋다.
    가독성은 중요하다.
    특별한 경우라는 것은 규칙을 어겨야 할 정도로 특별한 것이 아니다.
    허나 실용성은 순수성에 우선한다.
    오류 앞에서 절대 침묵하지 말지어다.
    명시적으로 오류를 감추려는 의도가 아니라면.
    모호함을 앞에 두고, 이를 유추하겠다는 유혹을 버려라.
    어떤 일에든 명확한 - 바람직하며 유일한 - 방법이 존재한다.
    비록 그대가 우둔하여 그 방법이 처음에는 명확해 보이지 않을지라도.
    지금 하는게 아예 안하는 것보다 낫다.
    아예 안하는 것이 지금 *당장*보다 나을 때도 있지만.
    구현 결과를 설명하기 어렵다면, 그 아이디어는 나쁘다.
    구현 결과를 설명하기 쉽다면, 그 아이디어는 좋은 아이디어일 수 있다.
    네임스페이스는 대박 좋은 아이디어다 -- 마구 남용해라!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because exceptions should be classes, the class naming convention
applies here.  However, you should use the suffix "Error" on your
exception names (if the exception actually is an error).</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153224Z">
        <seg>예외는 클래스이므로 클래스 명명 규칙을 그대로 사용한다.  하지만, 예외
이름의 끝에 "Error"라는 접미사를 사용해야 한다 (예외가 실제로 에러일
경우에).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because the PEPs are maintained as text files in a versioned
repository, their revision history is the historical record of the
feature proposal [1]_.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T044612Z">
        <seg>PEP는 버전이 매겨진 저장소 내의 텍스트 파일로 관리되기 때문에, 버전의 이력이
곧 기능 제안에 대한 기록이 된다. [1]_</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Blank Lines
-----------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150532Z">
        <seg>빈 줄
-----</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Block Comments
--------------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151948Z">
        <seg>블록 주석문
-----------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Block comments generally apply to some (or all) code that follows
them, and are indented to the same level as that code.  Each line of a
block comment starts with a ``#`` and a single space (unless it is
indented text inside the comment).</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130527T162159Z">
        <seg>블록 주석문은 일반적으로 블록 주석문 이후에 기술되는 일부(혹은 전체)
코드와 관련된 내용이며, 해당 코드와 같은 수준만큼 들여쓰게 된다.  블록
주석문의 각 행은 ``#``\ 문자와 한 개의 공백으로 시작된다(코멘트 내부에
들여쓰기된 텍스트가 있을 경우는 제외)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But most importantly: know when to be inconsistent -- sometimes the
style guide just doesn't apply.  When in doubt, use your best
judgment.  Look at other examples and decide what looks best.  And
don't hesitate to ask!</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T145824Z">
        <seg>하지만 무엇보다 중요한 것은, 어느 순간에 일관성을 버려야 할 지 알아야
한다는 것이다 - 어떤 순간에는 스타일 가이드를 적용하지 않을 수 있다.
의심이 든다면 최선을 다해 판단해라.  다른 예제들을 살펴보고 어떤 것이
가장 좋아 보이는지 결정하라.  그리고 주저하지 말고 질문하라!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But sometimes, this is useful::</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T152103Z">
        <seg>하지만 이런 주석문은 유용할 때가 있다.

::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C dialect
=========</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T043351Z">
        <seg>C 방언
======</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Circular references</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T164926Z">
        <seg>순환 참조</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class Names
~~~~~~~~~~~</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153147Z">
        <seg>클래스 이름
~~~~~~~~~~~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Class naming conventions apply here, although you should add the
  suffix "Error" to your exception classes, if the exception is an
  error.  Non-error exceptions need no special suffix.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154625Z">
        <seg>예외에는 클래스 이름 규칙이 적용되지만, 이 예외 클래스가 에러를
  나타낼 경우에는 "Error"를 접미사로 붙여야 한다.  에러가 아닌 예외의
  경우에는 특별한 접미사를 붙일 필요가 없다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Code in the core Python distribution should always use the ASCII or
Latin-1 encoding (a.k.a. ISO-8859-1).  For Python 3.0 and beyond,
UTF-8 is preferred over Latin-1, see PEP 3120.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150711Z">
        <seg>파이썬 배포본 내의 코드는 항상 ASCII 혹은 Latin-1 인코딩(ISO-8859-1
이라고도 한다)을 사용해야 한다.  파이썬 3.0 이상 버전에서는 Latin-1
대신 UTF-8을 권장한다(PEP 3120을 참고하라).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Code lay-out
============</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T130547Z">
        <seg>코드 레이아웃
=============</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Codetags have been under discussion and in use (hundreds of codetags
in the Python 2.4 sources) in many places (e.g., c2_) for many years.
See References_ for further historic and current information.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T060934Z">
        <seg>Codetags have been under discussion and in use (hundreds of codetags
in the Python 2.4 sources) in many places (e.g., c2_) for many years.
See 참조_ for further historic and current information.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments
--------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T163224Z">
        <seg>주석
----</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments
========</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151739Z">
        <seg>주석문
======</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments should be complete sentences.  If a comment is a phrase or
sentence, its first word should be capitalized, unless it is an
identifier that begins with a lower case letter (never alter the case
of identifiers!).</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151806Z">
        <seg>주석은 완결된 문장 형태로 작성한다.  한 구절 혹은 문장으로 이루어진
주석을 작성할 경우, 첫 번째 단어를 대문자로 기술한다.  예외적으로,
이 첫 번째 단어가 소문자로 된 식별자일 경우에는 그대로 소문자로 기술한다
(이렇게 식별자를 주석에 사용할 경우에는 절대 소문자/대문자를 바꾸지
말아야 한다).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comments that contradict the code are worse than no comments.  Always
make a priority of keeping the comments up-to-date when the code
changes!</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151752Z">
        <seg>코드의 내용과 동떨어진 주석이 있는 것보다는 아예 주석이 없는 편이 낫다.
주석은 항상 코드의 변경에 맞추어 최신의 상태를 유지하도록 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Compatibility of C API</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T171032Z">
        <seg>C API의 호환성</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Concerns</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165202Z">
        <seg>우려</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constants
~~~~~~~~~</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153751Z">
        <seg>상수
~~~~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Constants are usually defined on a module level and written in all
capital letters with underscores separating words.  Examples include
``MAX_OVERFLOW`` and ``TOTAL``.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153803Z">
        <seg>상수는 보통 모듈 수준에서 정의되며, 대문자 및 단어를 구분하기 위한
언더스코어 문자로 구성된다.  ``MAX_OVERFLOW``와 ``TOTAL`` 등의 예를
들 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Continuation lines should align wrapped elements either vertically
using Python's implicit line joining inside parentheses, brackets and
braces, or using a hanging indent.  When using a hanging indent the
following considerations should be applied; there should be no
arguments on the first line and further indentation should be used to
clearly distinguish itself as a continuation line.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150038Z">
        <seg>여러 줄에 걸쳐 코드를 작성할 경우 파이썬의 괄호, 중괄호('{'), 대괄호
('[')처럼 암시적으로 여러 줄을 결합하는 기능을 사용하거나, 들여쓰기
(hanging indent)를 사용하여 코드의 요소들을 수직으로 정렬해야 한다.
들여쓰기를 사용하려면 다음과 같은 사항을 고려해야 한다.  첫 번째 줄에
인수가 오면 안 되며, 들여쓰기를 계속 사용할 경우 행이 계속된다는 사실
을 분명히 파악할 수 있도록 사용해야 한다.(역자 주: 문장 중간에 들여쓰기를
사용하는 형식을 hanging indent라고 함.  다음 URL을 참고하라.
http://www.fanhow.com/images/9/91/How_to_Create_hanging_indent_using_CSS_2.png)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conventions</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T131412Z">
        <seg>관례</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Conventions for writing good documentation strings
(a.k.a. "docstrings") are immortalized in PEP 257.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T152128Z">
        <seg>좋은 문서화 문자열(Documentation String, docstring이라고도 한다)을
작성하기 위한 규칙으로 PEP 257가 널리 알려져 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Copyright</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125943Z">
        <seg>저작권</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Copyright
    
    This document has been placed in the public domain.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170545Z">
        <seg>저작권
    
    이 문서는 퍼블릭 도메인에 속한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Copyright
---------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T130805Z">
        <seg>저작권
------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Copyright
=========</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T120945Z">
        <seg>저작권
======</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Current Solution</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165731Z">
        <seg>현재 해결책</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Definitely not::</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151727Z">
        <seg>절대 안됨::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Descriptive: Naming Styles
--------------------------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T152534Z">
        <seg>표현: 명명 스타일
-----------------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Design and Implementation</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165428Z">
        <seg>설계 및 구현</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Designing for inheritance
~~~~~~~~~~~~~~~~~~~~~~~~~</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153809Z">
        <seg>상속을 위한 설계
~~~~~~~~~~~~~~~~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Developers with hg push privileges for the `PEP repository`_ may claim
PEP numbers directly by creating and committing a new PEP. When doing so,
the developer must handle the tasks that would normally be taken care of by
the PEP editors (see `PEP Editor Responsibilities &amp; Workflow`_). This
includes ensuring the initial version meets the expected standards for
submitting a PEP. Alternately, even developers may choose to submit PEPs
through the PEP editors. When doing so, let the PEP editors know you have
hg push privileges and they can guide you through the process of updating
the PEP repository directly.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T042519Z">
        <seg>`PEP 저장소`_\ 에 대한 hg push 권한을 가진 개발자는 새로운 PEP를 생성 및
커밋함으로써 직접 PEP 번호를 얻을 수 있다.  그렇게 할 때에는, 개발자는
일반적으로 PEP 편집자가 담당하는 업무를 처리하여야 한다(`PEP 편집자의 책임
및 흐름`_ 참조).  초기 버전이 PEP를 제출하는 데에 있어 따라야 하는 표준을
충족하는지 확인하는 것을 포함한다.  다른 방법으로, 개발자가 PEP를 PEP
편집자에게 제출하는 것을 선택할 소수도 있다.  그럴 경우에는 당신이 hg push
권한을 갖고 있다는 것을 PEP 편집자에게 알림으로써 PEP 저장소에 직접
업데이트하는 절차에 대한 안내를 받기 바란다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Developers(s)</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T130040Z">
        <seg>개발자</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Development and Discussion</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170636Z">
        <seg>개발 및 논의</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Discussion</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165602Z">
        <seg>논의</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Documentation Strings
---------------------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T152117Z">
        <seg>문서화 문자열
-------------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Documentation Strings
=====================</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T051919Z">
        <seg>문서화 문자열
=============</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each PEP must begin with an RFC 822 style header preamble.  The headers
must appear in the following order.  Headers marked with "*" are
optional and are described below.  All other headers are required. ::</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130605T063318Z">
        <seg>각 PEP의 첫머리에는 RFC 822 스타일의 헤더가 반드시 있어야 한다.  각 헤더는
다음의 순서를 따른다.  "*" 표시가 된 헤더는 생략할 수 있으며, 아래에
설명한다. 그 외의 헤더는 필수이다.

::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each PEP must have a champion -- someone who writes the PEP using the
style and format described below, shepherds the discussions in the
appropriate forums, and attempts to build community consensus around
the idea.  The PEP champion (a.k.a. Author) should first attempt to
ascertain whether the idea is PEP-able.  Posting to the
comp.lang.python newsgroup (a.k.a. python-list@python.org mailing
list) or the python-ideas mailing list is the best way to go about this.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125108Z">
        <seg>각 PEP에는 다음에 기술된 문체와 형식에 따라 PEP를 작성하고, 적절한 포럼에서
토의하며, 아이디어에 대한 커뮤니티의 합의를 구축할 사람이 필요하며, 그러한
역할을 담당하는 사람을 챔피언이라 한다.  이러한 PEP 챔피언(혹은 저자)는
아이디어가 PEP가 될 수 있는지 일단 검토해야 한다.  comp.lang.python 뉴스그룹
(혹은 python-list@python.org 메일링 리스트) 또는 python-ideas 메일링 리스트에
게재하는 것이 최선의 방법이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each PEP should have the following parts:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125517Z">
        <seg>각 PEP는 다음과 같은 부분을 갖추어야 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Early core developer attempts to use function annotations revealed
  inconsistent, ad-hoc annotation styles.  For example:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T155438Z">
        <seg>함수 어노테이션을 사용하던 초기의 핵심 개발자들은 일관성 없는
  임기응변식 어노테이션 스타일이 존재한다는 것을 발견했다.  예를 들면:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Easter Egg</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T163012Z">
        <seg>이스터 에그</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Effects on Other Tools</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170659Z">
        <seg>다른 도구에 대한 영향</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Encodings (PEP 263)
-------------------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150629Z">
        <seg>인코딩 (PEP 263)
----------------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170619Z">
        <seg>예</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Example:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T164039Z">
        <seg>예:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Examples</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T164654Z">
        <seg>예</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Examples:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T164047Z">
        <seg>예:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Exception Names
~~~~~~~~~~~~~~~</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153208Z">
        <seg>예외 이름
~~~~~~~~~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Extra blank lines may be used (sparingly) to separate groups of
related functions.  Blank lines may be omitted between a bunch of
related one-liners (e.g. a set of dummy implementations).</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150552Z">
        <seg>서로 연관이 있는 함수들의 묶음을 구분하기 위해 빈 줄을 추가로 사용할
수 있다.  반대로 한 줄짜리 구현 코드가 뭉쳐 있을 경우 이러한 빈 줄을
생략할 수도 있다. (예: 일련의 미구현, 임시 코드)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Features</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T164322Z">
        <seg>기능</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Files using ASCII should not have a coding cookie.  Latin-1 (or UTF-8)
should only be used when a comment or docstring needs to mention an
author name that requires Latin-1; otherwise, using ``\x``, ``\u`` or
``\U`` escapes is the preferred way to include non-ASCII data in
string literals.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150723Z">
        <seg>ASCII 인코딩을 사용하는 파일은 코딩 쿠키를 포함하면 안 된다. 주석 혹은
docstring에서 Latin-1 문자로 기록된 문서 작성자의 이름을 언급할
필요가 있을 때에만 Latin-1(혹은 UTF-8)을 사용한다.  혹은, 비 ASCII
데이터를 문자 상수에 넣으려면 ``\x``, ``\u``, ``\U`` 등의 이스케이프
문자를 사용하길 권한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Following a discussion on python-ideas, the proposal should be sent as a
draft PEP to the PEP editors &lt;peps@python.org&gt;.  The draft must be written
in PEP style as described below, else it will be sent back without further
regard until proper formatting rules are followed (although minor errors
will be corrected by the editors).</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125146Z">
        <seg>python-ideas에서의 논의에 따라, 그 제안은 PEP 초안으로서 PEP 편집자
&lt;peps@python.org&gt; 메일링 리스트에 전달되어야 한다.  초안은 아래에 기술하는
PEP 형식에 맞추어 기술하여야 하며, 그렇지 않으면 올바른 형식을 따를 때까지
검토 없이 반송된다(작은 오류는 편집자가 수정한다).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Footnotes
---------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T163303Z">
        <seg>각주
----</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For C code that needs to support versions of Python older than 2.3,
  you can include this after including ``Python.h``::</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T054700Z">
        <seg>파이썬 2.3 버전 이전을 지원해야하는 C 코드에서는,
  ``Python.h``\ 를 포함한 후에 다음을 포함한다. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For Python 3.0 and beyond, the following policy is prescribed for the
standard library (see PEP 3131): All identifiers in the Python
standard library MUST use ASCII-only identifiers, and SHOULD use
English words wherever feasible (in many cases, abbreviations and
technical terms are used which aren't English). In addition, string
literals and comments must also be in ASCII. The only exceptions are
(a) test cases testing the non-ASCII features, and
(b) names of authors. Authors whose names are not based on the
latin alphabet MUST provide a latin transliteration of their
names.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151145Z">
        <seg>파이썬 3.0 이상 버전에서는 표준 라이브러리에 대해 다음과 같은 정책을
취하고 있다(PEP 3131을 참고): 파이썬 표준 라이브러리에서는 ASCII
문자만으로 구성된 식별자를 사용해야 하며, 모든 경우에 적절한 영어 단어를
사용하는 것이 좋다(많은 경우, 어어라고 할 수 없는 약어와 기술 용어가
쓰이곤 한다).  또한, 문자 상수와 주석 또한 ASCII로 작성되어야
한다. 유일한 예외는
(a) 비 ASCII 문자가 포함된 기능을 테스트하는 테스트 케이스
(b) 작성자의 이름. 라틴 알파벳 이외의 문자를 사용하는 이름을 가진 작성자는
자신의 이름에 대한 라틴어 음역을 같이 제공해야 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a PEP to be accepted it must meet certain minimum criteria.  It
must be a clear and complete description of the proposed enhancement.
The enhancement must represent a net improvement.  The proposed
implementation, if applicable, must be solid and must not complicate
the interpreter unduly.  Finally, a proposed enhancement must be
"pythonic" in order to be accepted by the BDFL.  (However, "pythonic"
is an imprecise term; it may be defined as whatever is acceptable to
the BDFL.  This logic is intentionally circular.)  See PEP 2 [2]_ for
standard library module acceptance criteria.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T045132Z">
        <seg>PEP가 수용되기 위해서는 몇 가지 최소한의 요건을 갖추어야 한다.  그것은
제안하는 개선사항에 대한 명확하고 완전한 기술이어야 한다.  개선은 완전한
구현을 표현해야 한다.  제안하는 구현은 가능하다면 변함이 없고 인터프리터를
지나치게 복잡하게 만들지 않아야 한다.  마지막으로, 제안하는 개선 사항이
BDFL에 의해 수용되기 위해서는 반드시 "파이썬다와야(pythonic)" 한다.  (그러나,
"파이썬다움"은 부정확한 단어이며, BDFL이 수용하느냐에 달려있다. 이것은 순환
논리이다.)  표준 라이브러리 모듈의 수용 요건에 대해서는 PEP 2\ [2]_\ 를
참조하라.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a PEP where final pronouncement will be made on a list other than
python-dev, a Discussions-To header will indicate the mailing list
or URL where the pronouncement will occur. A temporary Discussions-To header
may also be used when a draft PEP is being discussed prior to submission for
pronouncement. No Discussions-To header is necessary if the PEP is being
discussed privately with the author, or on the python-list, python-ideas
or python-dev mailing lists.  Note that email addresses in the
Discussions-To header will not be obscured.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130605T063434Z">
        <seg>최종적인 공표가 python-dev 이외의 리스트에서 이루어진 PEP에 대해서는,
Discussions-To 헤더에 공표가 이루어진 메일링 리스트 또는 URL을 지시하도록
한다.  공표를 제출하기 전에 논의 중에 있는 PEP 초안은 Discussions-To 헤더를
임시로 사용할 수 있다.  저자가 개인적으로 또는 python-list, python-ideas,
python-dev 등에서 논의한 PEP에 대해서는 Discussions-To 헤더가 필수적이다.
Discussions-To 헤더의 이메일 주소는 스팸 방지 처리를 하지 않는다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For each new PEP that comes in an editor does the following:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T022907Z">
        <seg>편집자 리스트에 새로 들어온 PEP는 다음과 같은 일을 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, do not rely on CPython's efficient implementation of
  in-place string concatenation for statements in the form ``a += b``
  or ``a = a + b``.  Those statements run more slowly in Jython.  In
  performance sensitive parts of the library, the ``''.join()`` form
  should be used instead.  This will ensure that concatenation occurs
  in linear time across various implementations.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154346Z">
        <seg>예를 들면, CPython의 간단한 문자열 결합(``a += b``, ``a = a + b``
  같은 형태의)은 효율적으로 구현되어 있다. 하지만 Jython에서는 위 구문이
  더 느리게 실행될 수 있으므로, CPython의 구현에 지나치게 의존해선 안 된다.
  성능에 민감한 부분에서 문자열 결합 기능을 사용해야
  할 경우 ``''.join()`` 메서드를 대신 사용해야 한다.  이 메서드는
  다양한 파이썬 구현체에서 문자열 결합이 선형적 실행 시간을 갖도록
  보장해 준다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, use::</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154726Z">
        <seg>예를 들면, 다음과 같은 구문을 사용한다. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For new projects, spaces-only are strongly recommended over tabs.
Most editors have features that make this easy to do.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150405Z">
        <seg>새로운 프로젝트를 만들 경우 탭 문자 대신 공백 문자만을 사용하도록 하자.
대부분의 편집기에서는 이러한 작업을 쉽게 처리할 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For really old code that you don't want to mess up, you can continue
to use 8-space tabs.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150016Z">
        <seg>정말 오래된 코드를 엉망으로 만들고 싶지 않은 경우라면, 8개의 공백을
계속 사용해도 된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function Names
~~~~~~~~~~~~~~</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153306Z">
        <seg>함수 이름
~~~~~~~~~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function and method arguments
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153345Z">
        <seg>함수와 메서드 인수
~~~~~~~~~~~~~~~~~~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Function names should be lowercase, with words separated by
underscores as necessary to improve readability.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153318Z">
        <seg>함수 이름은 소문자를 사용하며, 가독성을 높이기 위해 각 단어는
언더스코어로 구분하도록 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>General
-------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T163353Z">
        <seg>일반
----</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Global Variable Names
~~~~~~~~~~~~~~~~~~~~~</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153232Z">
        <seg>전역 변수 이름
~~~~~~~~~~~~~~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Guidelines for submitting patches and making changes</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T164507Z">
        <seg>패치와 변경사항의 제출에 대한 안내</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Habits to Avoid
===============</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T163059Z">
        <seg>피해야 할 습관
==============</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here is a hyperlink reference to the `Abstract`_ section.  The
    backquotes are optional since the reference text is a single word;
    we can also just write: Abstract_.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T060950Z">
        <seg>Here is a hyperlink reference to the `Abstract`_ section.  The
    backquotes are optional since the reference text is a single word;
    we can also just write: 초록_.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Historical Note</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T131325Z">
        <seg>참고 이력</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>History</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T130515Z">
        <seg>이력</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>History and Rationale</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170627Z">
        <seg>이력 및 근거</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>History of this Proposal</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T164107Z">
        <seg>이 제안의 이력</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How to Use This Template
========================</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T163408Z">
        <seg>이 템플릿의 사용법
==================</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>How you report a bug, or submit a PEP update depends on several
factors, such as the maturity of the PEP, the preferences of the PEP
author, and the nature of your comments.  For the early draft stages
of the PEP, it's probably best to send your comments and changes
directly to the PEP author.  For more mature, or finished PEPs you may
want to submit corrections to the Python `issue tracker`_ so that your
changes don't get lost.  If the PEP author is a Python developer, assign the
bug/patch to them, otherwise assign it to a PEP editor.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T042216Z">
        <seg>PEP에 대한 버그를 보고하거나 수정사항을 제출하는 방법은 몇 가지 요건에
따라 달라지는데, PEP의 성숙도, PEP 저자의 취향, 그리고 여러분의 의견의
성격 등이다.  PEP 작성 초반에는 여러분의 의견과 수정 사항을 PEP 저자에게
직접 전달하는 것이 최선일 것이다.  PEP가 어느 정도 다듬어졌거나 완료된
경우에는 수정 사항을 Python `이슈 트래커`_\ 에 제출함으로써 수정
사항을 잃어버리지 않도록 하는 것이 좋다.  PEP 저자가 Python 개발자인
경우, 버그/패치를 그들에게 할당하며, 그렇지 않은 경우에는 PEP 편집자에게
할당한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hyperlinks
----------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T163318Z">
        <seg>하이퍼링크
----------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a comment is short, the period at the end can be omitted.  Block
comments generally consist of one or more paragraphs built out of
complete sentences, and each sentence should end in a period.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151819Z">
        <seg>주석문이 짧을 경우 마지막에 오는 마침표는 생략할 수 있다.  블록 형태의
주석문은 일반적으로 완결된 문장들로 구성된 문단들이며, 각각의 문단은
마침표로 끝나야 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If a function argument's name clashes with a reserved keyword, it is
generally better to append a single trailing underscore rather than
use an abbreviation or spelling corruption.  Thus ``class_`` is better
than ``clss``.  (Perhaps better is to avoid such clashes by using a
synonym.)</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130527T162534Z">
        <seg>함수 인수의 이름이 예약어와 충돌할 경우, 일반적으로 인수 이름의 끝에
언더스코어 문자 하나를 추가해 주는 것이 약어를 사용하거나 맞춤법을
어기는 이름을 사용하는 것 보다 낫다.  그러므로 ``class_``\ 를 사용하는
것이 ``clss``\ 를 사용하는 것보다 낫다.  (아마 더 나은 방법은 동의어를
사용해서 이름 충돌을 피하는 방법일 것이다.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the PEP editors approve, they will assign the PEP a number, label it
as Standards Track, Informational, or Process, give it status "Draft",
and create and check-in the initial draft of the PEP.  The PEP editors
will not unreasonably deny a PEP.  Reasons for denying PEP status
include duplication of effort, being technically unsound, not
providing proper motivation or addressing backwards compatibility, or
not in keeping with the Python philosophy.  The BDFL can be consulted
during the approval phase, and is the final arbiter of the draft's
PEP-ability.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125201Z">
        <seg>PEP 편집자가 승인하면, PEP에 번호를 붙이고, 표준 트랙, 정보 혹은 프로세스의
라벨을 붙이고, "초안" 상태를 부여하여 PEP의 최초 초안을 체크인한다.  PEP
편집자는 이유 없이 PEP를 기각하지 않을 것이다.  PEP 상태를 기각하는 주된
이유는 노력의 중복을 초래하거나, 기술적으로 나쁘거나, 적절한 동기 또는 하위
호환성을 제공하지 못하거나, 파이썬 철학에 위배되는 것 등이다.  BDFL은 승인
단계에 관여할 수 있으며, 초안이 PEP가 될 수 있는지에 대한 최종 결정권을
갖는다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the PEP isn't ready, an editor will send it back to the author for
revision, with specific instructions.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T025043Z">
        <seg>PEP의 준비가 미흡하다면, 편집자는 구체적인 지침과 함께 저자에게
되돌려보내어 개정을 하도록 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the final decision on a PEP is to be made by a delegate rather than
directly by the BDFL, this will be recorded by including the
"BDFL-Delegate" header in the PEP.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125324Z">
        <seg>최종 결정이 BDFL에 의하여 직접 이루어지지 않고 위임에 의한 것인 경우에는,
PEP에 "BDFL-Delegate" 머리말로서 기록을 남긴다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the return value for the function is always None (because there
  is no meaningful return value), do not include the indication of the
  return type.</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T054857Z">
        <seg>함수의 반환 값이 항상 None이라면(의미 있는 반환 값이 없기 때문),
  반환 값에 대한 지시를 포함하지 않는다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If there are multiple authors, each should be on a separate line
following RFC 2822 continuation line conventions.  Note that personal
email addresses in PEPs will be obscured as a defense against spam
harvesters.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130605T063353Z">
        <seg>복수의 저자가 있는 경우, RFC 2822의 이어지는 행 관례에 따라 행을 나눈다.
PEP의 개인 이메일 주소는 무단으로 수집되는 것을 방지하기 위하여 읽기
어렵게 처리한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If this spelling causes local name clashes, then spell them ::</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130527T161259Z">
        <seg>만약 이름이 이미 선언된 로컬 이름과 충돌할 경우, 다음과 같이 기술한다. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you are interested in assuming ownership of a PEP, send a message
asking to take over, addressed to both the original author and the PEP
editors &lt;peps@python.org&gt;.  If the original author doesn't respond to
email in a timely manner, the PEP editors will make a unilateral
decision (it's not like such decisions can't be reversed :).</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T013833Z">
        <seg>PEP의 소유권을 맡는 것에 관심이 있다면, 원저자와 PEP 편집자들
&lt;peps@python.org&gt; 양쪽에 메시지를 보내어 접수 의사를 밝히도록 하라.
원저자가 제때 답장하지 않는다면, PEP 편집자들이 단독으로 결정을 내리게
된다(번복이 불가능한 것은 아니다).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you have to have Subversion, CVS, or RCS crud in your source file,
do it as follows. ::</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T152342Z">
        <seg>소스 파일에 Subversion, CVS, RCS 등이 포함되어 있다면 다음과 같이 버전을
기록한다. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Images
------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T163234Z">
        <seg>이미지
------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementation</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T131709Z">
        <seg>구현</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementation Details</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T130304Z">
        <seg>상세 구현</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementation Proposal</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165227Z">
        <seg>구현 제안</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementation Strategy</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T164950Z">
        <seg>구현 전략</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Implementations</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165647Z">
        <seg>구현</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Imports
-------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150753Z">
        <seg>임포트
------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Imports should be grouped in the following order:</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130527T162106Z">
        <seg>임포트 구문은 다음 순서에 따라 그룹별로 기술한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, the following special forms using leading or trailing
underscores are recognized (these can generally be combined with any
case convention):</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T152812Z">
        <seg>또한, 다음과 같이 처음이나 끝에 언더스코어를 사용하는 특별한 형식이
있다 (이들은 보통 대소문자 관련 규칙과 함께 쓰일 수 있다).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In general, Standards track PEPs are no longer modified after they have
reached the Final state. Once a PEP has been completed, the Language and
Standard Library References become the formal documentation of the expected
behavior.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125456Z">
        <seg>일반적으로, 표준 트랙 PEP는 최종 상태에 도달한 이후에는 더 이상 수정되지
않는다. PEP가 일단 완료되면, 언어 및 표준 라이브러리 레퍼런스가 기대되는
작용에 대한 형식적 문서가 된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In some fonts, these characters are indistinguishable from the
numerals one and zero.  When tempted to use 'l', use 'L' instead.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153035Z">
        <seg>특정 폰트에서는 이들 글자를 숫자 일, 영과 구별할 수 없다.  'l'을 굳
이 사용해야 할 경우에는 차라리 'L'을 사용하도록 하자.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Indentation
-----------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150002Z">
        <seg>들여쓰기
--------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Informational and Process PEPs may be updated over time to reflect changes
to development practices and other details. The precise process followed in
these cases will depend on the nature and purpose of the PEP being updated.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125503Z">
        <seg>정보 및 프로세스 PEP는 개발 사례 및 기타 세부 사항에 대한 변경 사항을 반영하기
위해 시간이 지남에 따라 갱신될 수 있다.  정확한 과정은 갱신되는 PEP의 성격과
목적에 따라 달라진다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inline Comments
---------------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T152018Z">
        <seg>인라인 주석문
-------------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Inline comments are unnecessary and in fact distracting if they state
the obvious.  Don't do this::</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T152051Z">
        <seg>뻔한 내용의 인라인 주석문은 불필요하며, 사실 방해물이라 할 수 있다.
이런 주석문은 피하자.

::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Interface</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170201Z">
        <seg>인터페이스</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introduction</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T130028Z">
        <seg>도입</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Introduction
============</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T130530Z">
        <seg>도입
====</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It occasionally becomes necessary to transfer ownership of PEPs to a
new champion.  In general, it is preferable to retain the original author as
a co-author of the transferred PEP, but that's really up to the
original author.  A good reason to transfer ownership is because the
original author no longer has the time or interest in updating it or
following through with the PEP process, or has fallen off the face of
the 'net (i.e. is unreachable or not responding to email).  A bad
reason to transfer ownership is because the author doesn't agree with the
direction of the PEP.  One aim of the PEP process is to try to build
consensus around a PEP, but if that's not possible, an author can always
submit a competing PEP.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T013155Z">
        <seg>때로는 PEP에 대한 소유권을 새로운 챔피언에게 이양할 필요가 있다.
일반적으로, 원래의 저자가 공저자로서 계속 남도록 하지만, 이는 원저자가
판단할 문제이다.  소유권을 이양하는 좋은 이유로는, 원저자가 PEP를
절차에 따라 관리할 시간이나 흥미가 없다거나 인터넷에서 사라진 경우
(연락 두절 및 이메일에 답장을 하지 않음) 등이 있다.  좋지 못한
이유로는 저자가 PEP의 방향에 동의하지 않는 것이다.  PEP 절차의 유일한
목표는 PEP에 대한 합의를 이루어내는 것이지만, 그것이 불가능하다면,
저자는 언제든지 경쟁적인 PEP를 제출할 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It's okay to say this though::</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150910Z">
        <seg>하지만 이렇게 사용하는 것은 괜찮다.

::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Java Documentation</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170045Z">
        <seg>Java 문서</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Limit all lines to a maximum of 79 characters.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150418Z">
        <seg>한 행에는 최대 79글자까지만 넣도록 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Long time Pythoneer Tim Peters succinctly channels the BDFL's
    guiding principles for Python's design into 20 aphorisms, only 19
    of which have been written down.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T162941Z">
        <seg>오랜 파이썬 선구자인 Tim Peters는 파이썬 설계에 대한 친절한 종신독재자의 가르침을 
    20개의 경구로 옮겼다. 여기에는 그 중 19개만을 적었다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Major Changes to Existing Modules</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170439Z">
        <seg>기존 모듈에 대한 주요 변경사항</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many PEPs are written and maintained by developers with write access
to the Python codebase.  The PEP editors monitor the python-checkins
list for PEP changes, and correct any structure, grammar, spelling, or
markup mistakes they see.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T041122Z">
        <seg>많은 PEP가 Python 코드 기반에 대한 쓰기 권한을 가진 개발자에 의해 쓰여지고
관리된다.  PEP 편집자는 python-checkins 목록에서 PEP의 변경 및 구조, 문법,
맞춤법, 마크업 실수 등에 대한 수정을 모니터한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many programmers who are familiar with TeX often write quotation marks
like this::</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T163150Z">
        <seg>Tex에 익숙한 많은 프로그래머들은 종종 따옴표를 다음과 같이 쓴다. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Maximum Line Length
-------------------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150410Z">
        <seg>한 행의 최대 길이
-----------------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Method Names and Instance Variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153632Z">
        <seg>메서드 이름과 인스턴스 변수
~~~~~~~~~~~~~~~~~~~~~~~~~~~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Method definitions inside a class are separated by a single blank
line.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150542Z">
        <seg>클래스의 메서드 정의는 한 줄을 띄워서 구분한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Minor Changes to Existing Modules</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170451Z">
        <seg>기존 모듈에 대한 작은 변경사항</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Miscellaneous issues:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170859Z">
        <seg>기타 이슈:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modules or packages should define their own domain-specific base
  exception class, which should be subclassed from the built-in
  Exception class.  Always include a class docstring.  E.g.::</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154612Z">
        <seg>모듈, 패키지는 자신만의 특정 도메인을 기반으로 하는 예외 클래스를
  정의해야 한다. 이들 예외 클래스는 파이썬에 내장된 Exception 클래스를
  상속한다.  클래스 docstring을 항상 포함시켜야 한다. 예::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modules should have short, all-lowercase names.  Underscores can be
used in the module name if it improves readability.  Python packages
should also have short, all-lowercase names, although the use of
underscores is discouraged.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153102Z">
        <seg>모듈은 소문자로 이루어진 짧은 이름을 사용해야 한다.  모듈 이름의 가독성을
높이기 위해 언더스코어를 사용할 수 있다.  파이썬 패키지 또한
소문자로 이루어진 짧은 이름을 사용해야 한다.  하지만 패키지의 경우에는
언더스코어를 가급적 사용하지 않는다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modules that are designed for use via ``from M import *`` should use
the ``__all__`` mechanism to prevent exporting globals, or use the
older convention of prefixing such globals with an underscore (which
you might want to do to indicate these globals are "module
non-public").</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153258Z">
        <seg>``from M import *`` 구문을 통해 사용할 수 있도록 설계된 모듈들은
``__all__`` 메커니즘을 사용하여 전역적으로 노출되는 것을 방지하거나,
전역 객체에 언더스코어를 붙이는 예전의 규칙을 사용해야 한다 (이들 전역
객체를 "비 public 모듈"로 표시하고 싶을 경우 사용한다).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Motivation</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T164540Z">
        <seg>동기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Names to Avoid
~~~~~~~~~~~~~~</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153017Z">
        <seg>피해야 할 이름
~~~~~~~~~~~~~~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Naming Conventions
==================</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T152408Z">
        <seg>명명 규칙
=========</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Naming conventions
==================</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T131510Z">
        <seg>명명 관례
=========</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Never mix tabs and spaces.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150253Z">
        <seg>절대 탭 문자와 공백 문자를 섞어 쓰지 마라.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Never use the characters 'l' (lowercase letter el), 'O' (uppercase
letter oh), or 'I' (uppercase letter eye) as single character variable
names.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153025Z">
        <seg>'l' (소문자 L), 'O' (대문자 O), 'I' (대문자 I) 한 글자를 변수 이름으로
사용하지 않는다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New Modules</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170418Z">
        <seg>새로운 모듈</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>New features for Python 2.2</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T131609Z">
        <seg>파이썬 2.2의 새로운 기능</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No-longer-supported platforms
-----------------------------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T130748Z">
        <seg>더 이상 지원하지 않는 플랫폼
----------------------------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No:  if type(obj) is type(1):</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T155227Z">
        <seg>나쁨: if type(obj) is type(1):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No:  import sys, os</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130527T161218Z">
        <seg>나쁨: import sys, os</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No: if len(seq)
          if not len(seq)</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130527T161724Z">
        <seg>나쁨: if len(seq)
            if not len(seq)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>No::</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151510Z">
        <seg>나쁨::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>None.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T130156Z">
        <seg>없음.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not only does this first step present the user a simpler landscape as
explained in the rationale_ section, but it also allows for a better
and more complete resolution of `Step 2`_ (see Prerequisite_).</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T054646Z">
        <seg>Not only does this first step present the user a simpler landscape as
explained in the 근거_ section, but it also allows for a better
and more complete resolution of `Step 2`_ (see Prerequisite_).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165826Z">
        <seg>참고</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note 1: Note that only the simple class name is used in the mangled
  name, so if a subclass chooses both the same class name and attribute
  name, you can still get name collisions.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154131Z">
        <seg>주의 1: 맹글링에는 단순히 클래스 이름만이 쓰인다는 것에 주의하자.
  그러므로 만약 자식 클래스가 동일한 클래스 이름과 어트리뷰트 이름을
  사용한다면, 여전히 이름 충돌이 일어날 가능성이 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note 1: Properties only work on new-style classes.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154029Z">
        <seg>주의 1: 프로퍼티는 새로운 스타일의 클래스에서만 동작한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note 1: See the argument name recommendation above for class methods.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153951Z">
        <seg>주의 1: 위에서 설명한 클래스 메서드의 인수 이름에 대한 권장사항을
  살펴보자.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note 2: Name mangling can make certain uses, such as debugging and
  ``__getattr__()``, less convenient.  However the name mangling
  algorithm is well documented and easy to perform manually.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154147Z">
        <seg>주의 2: 이름 맹글링을 사용하면 디버깅과 ``__getattr__()`` 등의 작업이
  조금 불편해진다. 하지만, 네임 맹글링 알고리즘에 대해서는 이미
  정리가 잘 되어 있으므로 직접 필요한 작업을 처리하는 것도 어렵지 않다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note 2: Try to keep the functional behavior side-effect free,
  although side-effects such as caching are generally fine.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154037Z">
        <seg>주의 2: 기능적 동작에 있어 부작용이 생기지 않도록 주의한다. 하지만
  캐시처럼 부작용이 주 기능인 경우는 일반적으로 괜찮다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note 3: Avoid using properties for computationally expensive
  operations; the attribute notation makes the caller believe that
  access is (relatively) cheap.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154119Z">
        <seg>주의 3: 큰 계산량을 요구하는 프로퍼티의 사용은 피한다. 호출자는
  어트리뷰트에 대한 접근 비용이 (비교적) 적다고 기대하게 된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note 3: Not everyone likes name mangling.  Try to balance the
  need to avoid accidental name clashes with potential use by
  advanced callers.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154159Z">
        <seg>주의 3: 모든 이가 네임 맹글링을 좋아하는 것은 아니다.  우발적인 이름
  충돌의 방지와, 해당 클래스를 사용하게 될 사람의 편의성 사이에서
  형평성을 찾도록 하자.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note, rules are there to be broken.  Two good reasons to break a
particular rule:</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T044454Z">
        <seg>규칙은 깨지기 위해 존재한다.  특정한 규칙을 무시해도 괜찮은 두 가지
경우를 살펴보자.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note: When using abbreviations in CapWords, capitalize all the
  letters of the abbreviation.  Thus HTTPServerError is better than
  HttpServerError.
- ``mixedCase`` (differs from CapitalizedWords by initial lowercase
  character!)
- ``Capitalized_Words_With_Underscores`` (ugly!)</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T152722Z">
        <seg>주의: CapWords에서 약어를 사용할 경우, 약어의 모든 글자를 대문자로
  기술한다.  그러므로 HTTPServerError가 HttpServerError를 사용하는
  것 보다 낫다.
- ``mixedCase`` (CapWords와 다른 점은 첫 글자가 소문자라는 것이다)
- ``Capitalized_Words_With_Underscores`` (이건 별로다!)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note: there is some controversy about the use of __names (see below).</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153744Z">
        <seg>주의: __names의 사용에 대해서는 다소 논란이 있다 (아래 내용을 참조).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notes:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170249Z">
        <seg>참고:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Notice</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170015Z">
        <seg>알림</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Older versions are available as:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T164006Z">
        <seg>오래된 버전은 아래에 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once a PEP has been accepted, the reference implementation must be
completed.  When the reference implementation is complete and incorporated
into the main source code repository, the status will be changed to "Final".</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125350Z">
        <seg>일단 PEP가 수용되면, 참조 구현을 반드시 완료하여야 한다.  참조 구현이 완료되어
주 소스 코드 저장소에 통합되면, 상태가 "최종(Final)"으로 변경된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the PEP is ready for the repository, a PEP editor will:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T025115Z">
        <seg>PEP가 저장소에 들어갈 준비를 갖추었으면, PEP 편집자는 다음과 같은 일을 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the authors have completed a PEP, they may request a review for
style and consistency from the PEP editors.  However, the content and
final acceptance of the PEP must be requested of the BDFL, usually via
an email to the python-dev mailing list.  PEPs are reviewed by the
BDFL and his chosen consultants, who may accept or reject a PEP or
send it back to the author(s) for revision.  For a PEP that is
predetermined to be acceptable (e.g., it is an obvious win as-is
and/or its implementation has already been checked in) the BDFL may
also initiate a PEP review, first notifying the PEP author(s) and
giving them a chance to make revisions.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125303Z">
        <seg>저자가 PEP를 완료하면, PEP 편집자에게 형식과 일관성에 대해 검토를 요청할
수 있다.  그러나, PEP의 내용과 최종 수용은 BDFL에게 요청하여야 하며, 보통
python-dev 메일링 리스트에 이메일을 보냄으로써 이루어진다.  BDFL과 그가
선택한 컨설턴트들이 PEP를 검토하여, PEP를 승인 또는 기각하거나 개정을 위해
저자에게 반송한다.  수용이 이미 정해진 PEP(명백한 것 및 구현이 이미 체크인
된 것 등)에 대해서도 BDFL이 PEP 검토에 착수하고 PEP 저자에게 알림으로써
개정의 기회를 부여할 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Once the champion has asked the Python community as to whether an
idea has any chance of acceptance, a draft PEP should be presented to
python-ideas.  This gives the author a chance to flesh out the draft
PEP to make properly formatted, of high quality, and to address
initial concerns about the proposal.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125137Z">
        <seg>챔피언이 파이썬 커뮤니티에 질문하여 아이디어가 받아들여질 가능성이 있다고
판단되면, 아이디어를 나타낸 PEP를 작성한다.  저자에게는 적합한 형식과 높은
품질을 갖추고 제안의 주된 관심사를 적시할 기회가 주어진다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of Guido's key insights is that code is read much more often than
it is written.  The guidelines provided here are intended to improve
the readability of code and make it consistent across the wide
spectrum of Python code.  As PEP 20 says, "Readability counts".</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T145903Z">
        <seg>귀도의 중요한 통찰 중 하나는 프로그램 코드가 작성되는 횟수보다는 사람에게
읽히는 횟수가 더 많다는 사실이다.  이 문서에서 제공하는 가이드라인은
코드의 가독성을 향상시키고 다양한 파이썬 코드에 일관성을 부여하고자하는
의도를 갖고 있다.  PEP 20에서 언급하듯, "가독성은 중요하다."</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open Issues</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165044Z">
        <seg>진행 중인 사항</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Open source projects with a global audience are encouraged to adopt a
similar policy.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151115Z">
        <seg>전세계인이 참여 중인 오픈 소스 프로젝트들은 이와 비슷한 정책을 따르도록
하고 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Optional::</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150150Z">
        <seg>선택사항::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Other Recommendations
---------------------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151525Z">
        <seg>기타 권고사항
-------------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP 207 indicates that reflexivity rules *are* assumed by Python.
  Thus, the interpreter may swap ``y &gt; x`` with ``x &lt; y``, ``y &gt;= x``
  with ``x &lt;= y``, and may swap the arguments of ``x == y`` and ``x !=
  y``.  The ``sort()`` and ``min()`` operations are guaranteed to use
  the ``&lt;`` operator and the ``max()`` function uses the ``&gt;``
  operator.  However, it is best to implement all six operations so
  that confusion doesn't arise in other contexts.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154525Z">
        <seg>PEP 207은 파이썬이 가정하고 있는 재귀적 규칙에 대해 설명하고 있다.
  이에 따르면, 인터프리터는 ``y &gt; x``를 ``x &lt; y``\ 으로, ``y &gt;= x``\ 를
  ``x &lt;= y``\ 라는 코드로 변형해서 사용할 수 있으며, ``x == y``\ 와
  ``x != y``\ 의 경우 두 인수의 위치를 서로 바꿀 수도 있다.
  ``sort()``\ 와 ``min()`` 명령은 ``&lt;`` 연산자를 사용하며, ``max()``
  함수는 ``&gt;`` 연산자를 사용한다.  어쨌든, 여섯 개의 연산을 모두
  구현하여 다른 맥락에서 혼동이 일어나지 않도록 하는 것이 가장 좋다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP Editor Responsibilities &amp; Workflow
======================================</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130528T024605Z">
        <seg>PEP 편집자의 책임 및 흐름
=========================</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP Editors
-----------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125012Z">
        <seg>PEP 편집자
----------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP Formats and Templates
=========================</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125721Z">
        <seg>PEP 형식 및 템플릿
==================</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP Header Preamble
===================</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130605T052343Z">
        <seg>PEP 헤더
========</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP Maintenance
---------------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125449Z">
        <seg>PEP 유지관리
------------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP Replacement</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T061902Z">
        <seg>PEP 대체</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP Review &amp; Resolution
-----------------------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125251Z">
        <seg>PEP 검토 및 해결
----------------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP Types
=========</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130605T060714Z">
        <seg>PEP의 종류
==========</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP Workflow
============</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T124947Z">
        <seg>PEP의 흐름
==========</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP authors are responsible for collecting community feedback on a PEP
before submitting it for review. However, wherever possible, long
open-ended discussions on public mailing lists should be avoided.
Strategies to keep the discussions efficient include: setting up a
separate SIG mailing list for the topic, having the PEP author accept
private comments in the early design phases, setting up a wiki page, etc.
PEP authors should use their discretion here.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125247Z">
        <seg>PEP 저자는 PEP를 검토를 위해 제출하기에 앞서 커뮤니티의 피드백을 수집하는
책임을 진다.  그러나, 공개된 메일링 리스트에서 끝없이 이어지는 논의는 가능한
피하도록 한다. 효율적인 논의를 위한 방법으로는 각 주제별로 SIG 메일링 리스트를
구성하거나, 초기 디자인 단계에서는 개인적인 조언을 얻거나, 위키 페이지를
구성하는 것 등이 있다.  이 부분은 PEP 저자의 재량에 맡긴다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP authors with hg push privileges for the PEP repository can update the
PEPs themselves by using "hg push" to submit their changes.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T011845Z">
        <seg>PEP 저장소에 대하여 hg push 권한을 가진 PEP 저자는 "hg push"를 사용하여
PEP를 직접 수정할 수 있다. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP editors don't pass judgment on PEPs.  They merely do the
administrative &amp; editorial part (which is generally a low volume task).</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T041345Z">
        <seg>PEP 편집자는 PEP에 대하여 심사하지 않는다.  그들은 단지 관리 및 편집 측면의
일을 수행한다(일반적으로 적은 분량의 업무이다).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP editorship is by invitation of the current editors.  The address
&lt;peps@python.org&gt; is a mailing list for contacting the PEP editors.  All
email related to PEP administration (such as requesting a PEP number
or providing an updated version of a PEP for posting) should be sent to
this address (no cross-posting please).</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125032Z">
        <seg>PEP의 편집자는 현재 편집자의 초대를 통해 선임한다.  &lt;peps@python.org&gt; 메일링
리스트를 통해 PEP 편집자에게 연락할 수 있다.  PEP 관리와 관련한 모든 이메일
(PEP 번호 요청 및 변경된 버전)은 이 주소로 발송하여야 한다(중복으로 글을
올리지 말기 바란다).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP review and resolution may also occur on a list other than python-dev
(for example, distutils-sig for packaging related PEPs that don't
immediately affect the standard library). In this case, the "Discussions-To"
heading in the PEP will identify the appropriate alternative list where
discussion, review and pronouncement on the PEP will occur.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125333Z">
        <seg>PEP 검토 및 해결은 python-dev 이외의 곳에서 이루어질 수도 있다(예를 들어,
표준 라이브러리에 직접적인 영향을 미치지 않는, 패키징에 관련해서는
distutils-sig에서 이루어진다). 이 경우, "Discussions-To" 머리말이 논의와
검토, 공고가 이루어질 메일링 리스트를 식별한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP stands for Python Enhancement Proposal.  A PEP is a design
document providing information to the Python community, or describing
a new feature for Python or its processes or environment.  The PEP
should provide a concise technical specification of the feature and a
rationale for the feature.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T124857Z">
        <seg>PEP는 파이썬 커뮤니티에 정보를 제공하거나, 새로운 기능이나 프로세스 또는
환경을 기술하는 설계 문서이다. PEP는 기능에 대한 간결한 기술 명세와 기능에
대한 이론적 근거를 제공해야 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 1
Title: PEP Purpose and Guidelines
Version: $Revision$
Last-Modified: $Date$
Author: Barry Warsaw, Jeremy Hylton, David Goodger, Nick Coghlan
Status: Active
Type: Process
Content-Type: text/x-rst
Created: 13-Jun-2000
Post-History: 21-Mar-2001, 29-Jul-2002, 03-May-2003, 05-May-2012,
              07-Apr-2013</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T123016Z">
        <seg>PEP: 1
Title: PEP의 목적 및 안내
Version: $Revision$
Last-Modified: $Date$
Author: Barry Warsaw, Jeremy Hylton, David Goodger, Nick Coghlan
Status: Active
Type: Process
Content-Type: text/x-rst
Created: 13-Jun-2000
Post-History: 21-Mar-2001, 29-Jul-2002, 03-May-2003, 05-May-2012,
              07-Apr-2013</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 10
Title: Voting Guidelines
Version: $Revision$
Last-Modified: $Date$
Author: barry@python.org (Barry Warsaw)
Status: Active
Type: Process
Created: 07-Mar-2002
Post-History: 07-Mar-2002</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T171432Z">
        <seg>PEP: 10
Title: 투표 안내
Version: $Revision$
Last-Modified: $Date$
Author: barry@python.org (Barry Warsaw)
Status: Active
Type: Process
Created: 07-Mar-2002
Post-History: 07-Mar-2002</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 100
Title: Python Unicode Integration
Version: $Revision$
Last-Modified: $Date$
Author: mal@lemburg.com (Marc-André Lemburg)
Status: Final
Type: Standards Track
Created: 10-Mar-2000
Python-Version: 2.0
Post-History:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T171559Z">
        <seg>PEP: 100
Title: Python 유니코드 통합
Version: $Revision$
Last-Modified: $Date$
Author: mal@lemburg.com (Marc-André Lemburg)
Status: Final
Type: Standards Track
Created: 10-Mar-2000
Python-Version: 2.0
Post-History:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 101
Title: Doing Python Releases 101
Version: $Revision$
Last-Modified: $Date$
Author: barry@python.org (Barry Warsaw), guido@python.org (Guido van Rossum)
Status: Active
Type: Informational
Created: 22-Aug-2001
Post-History:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T164159Z">
        <seg>PEP: 101
Title: 파이썬 릴리스하기 101
Version: $Revision$
Last-Modified: $Date$
Author: barry@python.org (Barry Warsaw), guido@python.org (Guido van Rossum)
Status: Active
Type: Informational
Created: 22-Aug-2001
Post-History:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 102
Title: Doing Python Micro Releases
Version: $Revision$
Last-Modified: $Date$
Author: anthony@interlink.com.au (Anthony Baxter), 
    barry@python.org (Barry Warsaw), 
    guido@python.org (Guido van Rossum)
Status: Superseded
Type: Informational
Created: 22-Aug-2001 (edited down on 9-Jan-2002 to become PEP 102)
Post-History:
Superseded-By: 101</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T164224Z">
        <seg>PEP: 102
Title: 파이썬 마이크로 릴리스하기
Version: $Revision$
Last-Modified: $Date$
Author: anthony@interlink.com.au (Anthony Baxter), 
    barry@python.org (Barry Warsaw), 
    guido@python.org (Guido van Rossum)
Status: Superseded
Type: Informational
Created: 22-Aug-2001 (edited down on 9-Jan-2002 to become PEP 102)
Post-History:
Superseded-By: 101</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 11
Title: Removing support for little used platforms
Version: $Revision$
Last-Modified: $Date$
Author: martin@v.loewis.de (Martin von Löwis)
Status: Active
Type: Process
Content-Type: text/x-rst
Created: 07-Jul-2002
Post-History: 18-Aug-2007</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T171509Z">
        <seg>PEP: 11
Title: 잘 쓰이지 않는 플랫폼에 대한 지원 중단
Version: $Revision$
Last-Modified: $Date$
Author: martin@v.loewis.de (Martin von Löwis)
Status: Active
Type: Process
Content-Type: text/x-rst
Created: 07-Jul-2002
Post-History: 18-Aug-2007</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 12
Title: Sample reStructuredText PEP Template
Version: $Revision$
Last-Modified: $Date$
Author: David Goodger &lt;goodger@python.org&gt;,
        Barry Warsaw &lt;barry@python.org&gt;
Status: Active
Type: Process
Content-Type: text/x-rst
Created: 05-Aug-2002
Post-History: 30-Aug-2002</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T163437Z">
        <seg>PEP: 12
Title: reStructuredText PEP 템플릿 견본
Version: $Revision$
Last-Modified: $Date$
Author: David Goodger &lt;goodger@python.org&gt;,
        Barry Warsaw &lt;barry@python.org&gt;
Status: Active
Type: Process
Content-Type: text/x-rst
Created: 05-Aug-2002
Post-History: 30-Aug-2002</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 160
Title: Python 1.6 Release Schedule
Version: $Revision$
Last-Modified: $Date$
Author: Fred L. Drake, Jr. &lt;fdrake@acm.org&gt;
Status: Final
Type: Informational
Created: 25-Jul-2000
Python-Version: 1.6
Post-History:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T164309Z">
        <seg>PEP: 160
Title: 파이썬 1.6 릴리스 일정
Version: $Revision$
Last-Modified: $Date$
Author: Fred L. Drake, Jr. &lt;fdrake@acm.org&gt;
Status: Final
Type: Informational
Created: 25-Jul-2000
Python-Version: 1.6
Post-History:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 2
Title: Procedure for Adding New Modules
Version: $Revision$
Last-Modified: $Date$
Author: Martijn Faassen &lt;faassen@infrae.com&gt;
Status: Final
Type: Process
Created: 07-Jul-2001
Post-History: 07-Jul-2001, 09-Mar-2002</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T171301Z">
        <seg>PEP: 2
Title: 새로운 모듈을 추가하는 절차
Version: $Revision$
Last-Modified: $Date$
Author: Martijn Faassen &lt;faassen@infrae.com&gt;
Status: Final
Type: Process
Created: 07-Jul-2001
Post-History: 07-Jul-2001, 09-Mar-2002</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 20
Title: The Zen of Python
Version: $Revision$
Last-Modified: $Date$
Author: tim@zope.com (Tim Peters)
Status: Active
Type: Informational
Content-Type: text/plain
Created: 19-Aug-2004
Post-History: 22-Aug-2004</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T163025Z">
        <seg>PEP: 20
Title: 파이썬 선(禪)
Version: $Revision$
Last-Modified: $Date$
Author: tim@zope.com (Tim Peters)
Status: Active
Type: Informational
Content-Type: text/plain
Created: 19-Aug-2004
Post-History: 22-Aug-2004</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 200
Title: Python 2.0 Release Schedule
Version: $Revision$
Last-Modified: $Date$
Author: Jeremy Hylton &lt;jeremy@alum.mit.edu&gt;
Status: Final
Type: Informational
Created:
Python-Version: 2.0
Post-History:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T164405Z">
        <seg>PEP: 200
Title: 파이썬 2.0 릴리스 일정
Version: $Revision$
Last-Modified: $Date$
Author: Jeremy Hylton &lt;jeremy@alum.mit.edu&gt;
Status: Final
Type: Informational
Created:
Python-Version: 2.0
Post-History:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 201
Title: Lockstep Iteration
Version: $Revision$
Last-Modified: $Date$
Author: barry@python.org (Barry Warsaw)
Status: Final
Type: Standards Track
Created: 13-Jul-2000
Python-Version: 2.0
Post-History: 27-Jul-2000</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T171616Z">
        <seg>PEP: 201
Title: Lockstep 이터레이션
Version: $Revision$
Last-Modified: $Date$
Author: barry@python.org (Barry Warsaw)
Status: Final
Type: Standards Track
Created: 13-Jul-2000
Python-Version: 2.0
Post-History: 27-Jul-2000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 202
Title: List Comprehensions
Version: $Revision$
Last-Modified: $Date$
Author: barry@python.org (Barry Warsaw)
Status: Final
Type: Standards Track
Created: 13-Jul-2000
Python-Version: 2.0
Post-History:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T164626Z">
        <seg>PEP: 202
Title: 리스트 Comprehensions
Version: $Revision$
Last-Modified: $Date$
Author: barry@python.org (Barry Warsaw)
Status: Final
Type: Standards Track
Created: 13-Jul-2000
Python-Version: 2.0
Post-History:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 203
Title: Augmented Assignments
Version: $Revision$
Last-Modified: $Date$
Author: thomas@python.org (Thomas Wouters)
Status: Final
Type: Standards Track
Created: 13-Jul-2000
Python-Version: 2.0
Post-History: 14-Aug-2000</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T171626Z">
        <seg>PEP: 203
Title: Augmented 할당
Version: $Revision$
Last-Modified: $Date$
Author: thomas@python.org (Thomas Wouters)
Status: Final
Type: Standards Track
Created: 13-Jul-2000
Python-Version: 2.0
Post-History: 14-Aug-2000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 204
Title: Range Literals
Version: $Revision$
Last-Modified: $Date$
Author: thomas@python.org (Thomas Wouters)
Status: Rejected
Type: Standards Track
Created: 14-Jul-2000
Python-Version: 2.0
Post-History:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T171632Z">
        <seg>PEP: 204
Title: Range 리터럴
Version: $Revision$
Last-Modified: $Date$
Author: thomas@python.org (Thomas Wouters)
Status: Rejected
Type: Standards Track
Created: 14-Jul-2000
Python-Version: 2.0
Post-History:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 205
Title: Weak References
Version: $Revision$
Last-Modified: $Date$
Author: Fred L. Drake, Jr. &lt;fdrake@acm.org&gt;
Status: Final
Type: Standards Track
Created:
Python-Version: 2.1
Post-History: 11-Jan-2001</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T164914Z">
        <seg>PEP: 205
Title: 약한 참조
Version: $Revision$
Last-Modified: $Date$
Author: Fred L. Drake, Jr. &lt;fdrake@acm.org&gt;
Status: Final
Type: Standards Track
Created:
Python-Version: 2.1
Post-History: 11-Jan-2001</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 206
Title: Python Advanced Library
Version: $Revision$
Last-Modified: $Date$
Author: A.M. Kuchling &lt;amk@amk.ca&gt;
Status: Withdrawn
Type: Informational
Created:
Post-History:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T171640Z">
        <seg>PEP: 206
Title: Python 고급 라이브러리
Version: $Revision$
Last-Modified: $Date$
Author: A.M. Kuchling &lt;amk@amk.ca&gt;
Status: Withdrawn
Type: Informational
Created:
Post-History:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 209
Title: Multi-dimensional Arrays
Version: $Revision$
Last-Modified: $Date$
Author: barrett@stsci.edu (Paul Barrett), oliphant@ee.byu.edu (Travis Oliphant)
Status: Withdrawn
Type: Standards Track
Created: 03-Jan-2001
Python-Version: 2.2
Post-History:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165359Z">
        <seg>PEP: 209
Title: 다차원 배열
Version: $Revision$
Last-Modified: $Date$
Author: barrett@stsci.edu (Paul Barrett), oliphant@ee.byu.edu (Travis Oliphant)
Status: Withdrawn
Type: Standards Track
Created: 03-Jan-2001
Python-Version: 2.2
Post-History:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 212
Title: Loop Counter Iteration
Version: $Revision$
Last-Modified: $Date$
Author: nowonder@nowonder.de (Peter Schneider-Kamp)
Status: Deferred
Type: Standards Track
Created: 22-Aug-2000
Python-Version: 2.1
Post-History:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165639Z">
        <seg>PEP: 212
Title: 루프 카운터 이터레이션
Version: $Revision$
Last-Modified: $Date$
Author: nowonder@nowonder.de (Peter Schneider-Kamp)
Status: Deferred
Type: Standards Track
Created: 22-Aug-2000
Python-Version: 2.1
Post-History:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 213
Title: Attribute Access Handlers
Version: $Revision$
Last-Modified: $Date$
Author: paul@prescod.net (Paul Prescod)
Status: Deferred
Type: Standards Track
Created: 21-Jul-2000
Python-Version: 2.1
Post-History:</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T042714Z">
        <seg>PEP: 213
Title: 어트리뷰트 접근 핸들러
Version: $Revision$
Last-Modified: $Date$
Author: paul@prescod.net (Paul Prescod)
Status: Deferred
Type: Standards Track
Created: 21-Jul-2000
Python-Version: 2.1
Post-History:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 214
Title: Extended Print Statement
Version: $Revision$
Last-Modified: $Date$
Author: barry@python.org (Barry Warsaw)
Status: Final
Type: Standards Track
Created: 24-Jul-2000
Python-Version: 2.0
Post-History: 16-Aug-2000</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165842Z">
        <seg>PEP: 214
Title: Print 문 확장
Version: $Revision$
Last-Modified: $Date$
Author: barry@python.org (Barry Warsaw)
Status: Final
Type: Standards Track
Created: 24-Jul-2000
Python-Version: 2.0
Post-History: 16-Aug-2000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 216
Title: Docstring Format
Version: $Revision$
Last-Modified: $Date$
Author: moshez@zadka.site.co.il (Moshe Zadka)
Status: Rejected
Type: Informational
Created: 31-Jul-2000
Post-History:
Superseded-By: 287</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170007Z">
        <seg>PEP: 216
Title: Docstring 형식
Version: $Revision$
Last-Modified: $Date$
Author: moshez@zadka.site.co.il (Moshe Zadka)
Status: Rejected
Type: Informational
Created: 31-Jul-2000
Post-History:
Superseded-By: 287</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 217
Title: Display Hook for Interactive Use
Version: $Revision$
Last-Modified: $Date$
Author: moshez@zadka.site.co.il (Moshe Zadka)
Status: Final
Type: Standards Track
Created: 31-Jul-2000
Python-Version: 2.1
Post-History:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170154Z">
        <seg>PEP: 217
Title: 대화식 사용을 위한 Display Hook
Version: $Revision$
Last-Modified: $Date$
Author: moshez@zadka.site.co.il (Moshe Zadka)
Status: Final
Type: Standards Track
Created: 31-Jul-2000
Python-Version: 2.1
Post-History:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 218
Title: Adding a Built-In Set Object Type
Version: $Revision$
Last-Modified: $Date$
Author: gvwilson@ddj.com (Greg Wilson), python@rcn.com (Raymond Hettinger)
Status: Final
Type: Standards Track
Created: 31-Jul-2000
Python-Version: 2.2
Post-History:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170233Z">
        <seg>PEP: 218
Title: 빌트인 Set 개체 유형의 추가
Version: $Revision$
Last-Modified: $Date$
Author: gvwilson@ddj.com (Greg Wilson), python@rcn.com (Raymond Hettinger)
Status: Final
Type: Standards Track
Created: 31-Jul-2000
Python-Version: 2.2
Post-History:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 219
Title: Stackless Python
Version: $Revision$
Last-Modified: $Date$
Author: gmcm@hypernet.com (Gordon McMillan)
Status: Deferred
Type: Standards Track
Created: 14-Aug-2000
Python-Version: 2.1
Post-History:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170317Z">
        <seg>PEP: 219
Title: 스택리스 파이썬
Version: $Revision$
Last-Modified: $Date$
Author: gmcm@hypernet.com (Gordon McMillan)
Status: Deferred
Type: Standards Track
Created: 14-Aug-2000
Python-Version: 2.1
Post-History:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 222
Title: Web Library Enhancements
Version: $Revision$
Last-Modified: $Date$
Author: A.M. Kuchling &lt;amk@amk.ca&gt;
Status: Deferred
Type: Standards Track
Created: 18-Aug-2000
Python-Version: 2.1
Post-History: 22-Dec-2000</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170402Z">
        <seg>PEP: 222
Title: 웹 라이브러리 개선
Version: $Revision$
Last-Modified: $Date$
Author: A.M. Kuchling &lt;amk@amk.ca&gt;
Status: Deferred
Type: Standards Track
Created: 18-Aug-2000
Python-Version: 2.1
Post-History: 22-Dec-2000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 223
Title: Change the Meaning of \x Escapes
Version: $Revision$
Last-Modified: $Date$
Author: tim@zope.com (Tim Peters)
Status: Final
Type: Standards Track
Created: 20-Aug-2000
Python-Version: 2.0
Post-History: 23-Aug-2000</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170603Z">
        <seg>PEP: 223
Title: \x 이스케이프의 의미 변경
Version: $Revision$
Last-Modified: $Date$
Author: tim@zope.com (Tim Peters)
Status: Final
Type: Standards Track
Created: 20-Aug-2000
Python-Version: 2.0
Post-History: 23-Aug-2000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 224
Title: Attribute Docstrings
Version: $Revision$
Last-Modified: $Date$
Author: mal@lemburg.com (Marc-André Lemburg)
Status: Rejected
Type: Standards Track
Created: 23-Aug-2000
Python-Version: 2.1
Post-History:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170812Z">
        <seg>PEP: 224
Title: 어트리뷰트 Docstrings
Version: $Revision$
Last-Modified: $Date$
Author: mal@lemburg.com (Marc-André Lemburg)
Status: Rejected
Type: Standards Track
Created: 23-Aug-2000
Python-Version: 2.1
Post-History:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 226
Title: Python 2.1 Release Schedule
Version: $Revision$
Last-Modified: $Date$
Author: Jeremy Hylton &lt;jeremy@alum.mit.edu&gt;
Status: Final
Type: Informational
Created: 16-Oct-2000
Python-Version: 2.1
Post-History:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170935Z">
        <seg>PEP: 226
Title: 파이썬 2.1 릴리스 일정
Version: $Revision$
Last-Modified: $Date$
Author: Jeremy Hylton &lt;jeremy@alum.mit.edu&gt;
Status: Final
Type: Informational
Created: 16-Oct-2000
Python-Version: 2.1
Post-History:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 227
Title: Statically Nested Scopes
Version: $Revision$
Last-Modified: $Date$
Author: jeremy@alum.mit.edu (Jeremy Hylton)
Status: Final
Type: Standards Track
Created: 01-Nov-2000
Python-Version: 2.1
Post-History:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170954Z">
        <seg>PEP: 227
Title: 정적으로 중첩된 범위
Version: $Revision$
Last-Modified: $Date$
Author: jeremy@alum.mit.edu (Jeremy Hylton)
Status: Final
Type: Standards Track
Created: 01-Nov-2000
Python-Version: 2.1
Post-History:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 229
Title: Using Distutils to Build Python
Version: $Revision$
Last-Modified: $Date$
Author: A.M. Kuchling &lt;amk@amk.ca&gt;
Status: Final
Type: Standards Track
Created: 16-Nov-2000
Post-History:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T171150Z">
        <seg>PEP: 229
Title: Distutils를 사용하여 파이썬을 빌드
Version: $Revision$
Last-Modified: $Date$
Author: A.M. Kuchling &lt;amk@amk.ca&gt;
Status: Final
Type: Standards Track
Created: 16-Nov-2000
Post-History:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 230
Title: Warning Framework
Version: $Revision$
Last-Modified: $Date$
Author: guido@python.org (Guido van Rossum)
Status: Final
Type: Standards Track
Created:
Python-Version: 2.1
Post-History: 05-Nov-2000</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T171214Z">
        <seg>PEP: 230
Title: 경고 프레임워크
Version: $Revision$
Last-Modified: $Date$
Author: guido@python.org (Guido van Rossum)
Status: Final
Type: Standards Track
Created:
Python-Version: 2.1
Post-History: 05-Nov-2000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 3
Title: Guidelines for Handling Bug Reports
Version: $Revision$
Last-Modified: $Date$
Author: jeremy@alum.mit.edu (Jeremy Hylton)
Status: Withdrawn
Type: Process
Created: 25-Sep-2000
Post-History:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T171315Z">
        <seg>PEP: 3
Title: 버그 리포트 처리 안내
Version: $Revision$
Last-Modified: $Date$
Author: jeremy@alum.mit.edu (Jeremy Hylton)
Status: Withdrawn
Type: Process
Created: 25-Sep-2000
Post-History:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 4
Title: Deprecation of Standard Modules
Version: $Revision$
Last-Modified: $Date$
Author: Martin von Löwis &lt;martin@v.loewis.de&gt;
Status: Active
Type: Process
Created: 1-Oct-2000
Post-History:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T063149Z">
        <seg>PEP: 4
Title: 표준 모듈의 금지
Version: $Revision$
Last-Modified: $Date$
Author: Martin von Löwis &lt;martin@v.loewis.de&gt;
Status: Active
Type: Process
Created: 1-Oct-2000
Post-History:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 42
Title: Feature Requests
Version: $Revision$
Last-Modified: $Date$
Author: Jeremy Hylton &lt;jeremy@alum.mit.edu&gt;
Status: Final
Type: Process
Created: 12-Sep-2000
Post-History:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T171526Z">
        <seg>PEP: 42
Title: 기능 요청
Version: $Revision$
Last-Modified: $Date$
Author: Jeremy Hylton &lt;jeremy@alum.mit.edu&gt;
Status: Final
Type: Process
Created: 12-Sep-2000
Post-History:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 5
Title: Guidelines for Language Evolution
Version: $Revision$
Last-Modified: $Date$
Author: paul@prescod.net (Paul Prescod)
Status: Active
Type: Process
Created: 26-Oct-2000
Post-History:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T171341Z">
        <seg>PEP: 5
Title: 언어 진화 안내
Version: $Revision$
Last-Modified: $Date$
Author: paul@prescod.net (Paul Prescod)
Status: Active
Type: Process
Created: 26-Oct-2000
Post-History:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 6
Title: Bug Fix Releases
Version: $Revision$
Last-Modified: $Date$
Author: aahz@pythoncraft.com (Aahz), anthony@interlink.com.au (Anthony Baxter)
Status: Active
Type: Process
Created: 15-Mar-2001
Post-History: 15-Mar-2001 18-Apr-2001 19-Aug-2004</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T171351Z">
        <seg>PEP: 6
Title: 버그 수정 릴리스
Version: $Revision$
Last-Modified: $Date$
Author: aahz@pythoncraft.com (Aahz), anthony@interlink.com.au (Anthony Baxter)
Status: Active
Type: Process
Created: 15-Mar-2001
Post-History: 15-Mar-2001 18-Apr-2001 19-Aug-2004</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 7
Title: Style Guide for C Code
Version: $Revision$
Last-Modified: $Date$
Author: Guido van Rossum &lt;guido@python.org&gt;
Status: Active
Type: Process
Content-Type: text/x-rst
Created: 05-Jul-2001
Post-History:</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T042840Z">
        <seg>PEP: 7
Title: C 코드 스타일 안내
Version: $Revision$
Last-Modified: $Date$
Author: Guido van Rossum &lt;guido@python.org&gt;
Status: Active
Type: Process
Content-Type: text/x-rst
Created: 05-Jul-2001
Post-History:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 8
Title: Style Guide for Python Code
Version: $Revision$
Last-Modified: $Date$
Author: Guido van Rossum &lt;guido@python.org&gt;,
        Barry Warsaw &lt;barry@python.org&gt;
Status: Active
Type: Process
Content-Type: text/x-rst
Created: 05-Jul-2001
Post-History: 05-Jul-2001</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T171404Z">
        <seg>PEP: 8
Title: 파이썬 코드 스타일 안내
Version: $Revision$
Last-Modified: $Date$
Author: Guido van Rossum &lt;guido@python.org&gt;,
        Barry Warsaw &lt;barry@python.org&gt;
Status: Active
Type: Process
Content-Type: text/x-rst
Created: 05-Jul-2001
Post-History: 05-Jul-2001</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEP: 9
Title: Sample Plaintext PEP Template
Version: $Revision$
Last-Modified: $Date$
Author: Barry Warsaw &lt;barry@python.org&gt;
Status: Active
Type: Process
Content-Type: text/plain
Created: 14-Aug-2001
Post-History:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T171420Z">
        <seg>PEP: 9
Title: 일반텍스트 PEP 템플릿 견본
Version: $Revision$
Last-Modified: $Date$
Author: Barry Warsaw &lt;barry@python.org&gt;
Status: Active
Type: Process
Content-Type: text/plain
Created: 14-Aug-2001
Post-History:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEPs can also be superseded by a different PEP, rendering the original
obsolete.  This is intended for Informational PEPs, where version 2 of
an API can replace version 1.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125423Z">
        <seg>PEP는 원래의 것을 쓸모 없게 만드는 다른 PEP로 대체될 수도 있다. 이것은
정보 PEP를 위한 것으로, 어떤 API의 버전 2는 버전 1을 대신할 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEPs may also have a Superseded-By header indicating that a PEP has
been rendered obsolete by a later document; the value is the number of
the PEP that replaces the current document.  The newer PEP must have a
Replaces header containing the number of the PEP that it rendered
obsolete.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130605T063546Z">
        <seg>Superseded-By 헤더는 이후의 문서에 의해 불필요하게 되었음을 가리키며,
현재의 문서를 대체하는 PEP의 번호를 기록한다.  이 경우 새로운 PEP는
반드시 Replaces 헤더에 불필요하게 된 PEP의 번호를 기록한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEPs may have a Requires header, indicating the PEP numbers that this
PEP depends on.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130605T062644Z">
        <seg>다른 PEP에 대한 의존성을 가지는 경우, 그 번호를 Requires 헤더에 기록한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>PEPs may include auxiliary files such as diagrams.  Such files must be
named ``pep-XXXX-Y.ext``, where "XXXX" is the PEP number, "Y" is a
serial number (starting at 1), and "ext" is replaced by the actual
file extension (e.g. "png").</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T011411Z">
        <seg>PEP에는 다이어그램과 같이 보조적인 파일이 포함될 수 있다.  그러한
파일에는 ``pep-XXXX-Y.ext``\ 와 같이 이름을 붙이며, "XXXX"는 PEP 번호,
"Y"는 일련번호(1부터 시작), "ext"는 실제 파일 확장자("png" 등)로
치환한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Package and Module Names
~~~~~~~~~~~~~~~~~~~~~~~~</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153044Z">
        <seg>패키지와 모듈 이름
~~~~~~~~~~~~~~~~~~</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Paragraphs inside a block comment are separated by a line containing a
single ``#``.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T152011Z">
        <seg>블록 주석문 내부의 문단들은 한 개의 ``#`` 문자를 포함한 빈 줄을 넣어
구분한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl Documentation</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170029Z">
        <seg>Perl 문서</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Pet Peeves
----------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151233Z">
        <seg>눈엣가시
--------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Plaintext PEPs are written with minimal structural markup that adheres
to a rigid style.  PEP 9 contains a instructions and a template [3]_
you can use to get started writing your plaintext PEP.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T044732Z">
        <seg>일반 텍스트 PEP는 엄격한 스타일을 따르는 최소한의 구조적 마크업으로 작성된다.
PEP 9에 일반 텍스트 PEP를 작성하는 방법에 대한 설명 및 템플릿\ [3]_\ 이 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prescriptive: Naming Conventions
--------------------------------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T152958Z">
        <seg>규정: 명명 규칙
---------------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Problem</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165306Z">
        <seg>문제</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Problems</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170325Z">
        <seg>문제점</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Procedure</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T130508Z">
        <seg>절차</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Procedure for declaring a module deprecated</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T063142Z">
        <seg>모듈 금지를 선언하는 절차</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Programming Recommendations
===========================</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154207Z">
        <seg>프로그래밍 권장사항
===================</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Prohibitions</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T130505Z">
        <seg>금지사항</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Proposal</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165405Z">
        <seg>제안</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Proposal:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T171539Z">
        <seg>제안:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Proposed Implementation
 
    There is a new object type called an attribute access handler. 
    Objects of this type have the following attributes:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165815Z">
        <seg>구현 제안
 
    There is a new object type called an attribute access handler. 
    Objects of this type have the following attributes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Proposed Interface</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170525Z">
        <seg>제안된 인터페이스</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Proposed Resolutions</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165216Z">
        <seg>제안된 해결책</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Proposed Solution</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T164941Z">
        <seg>제안된 해결책</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Proposed Syntax
 
    Special methods should declare themselves with declarations of the
    following form:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165743Z">
        <seg>제안 구문
 
    Special methods should declare themselves with declarations of the
    following form:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Public attributes are those that you expect unrelated clients of your
class to use, with your commitment to avoid backward incompatible
changes.  Non-public attributes are those that are not intended to be
used by third parties; you make no guarantees that non-public
attributes won't change or even be removed.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153838Z">
        <seg>public 어트리뷰트는 당신이 만든 클래스를 사용하는 클라이언트들이 실제로
접근하게 될 어트리뷰트로, 하위 호환성 유지를 고려해야 한다.
비 public 어트리뷰트는 서드 파티가 사용할 수 없도록 설계된
어트리뷰트이다.  비 public 어트리뷰트는 이후에 변경되거나 제거할 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Put any relevant ``__all__`` specification after the imports.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151007Z">
        <seg>임포트 구문 다음에는 ``__all__`` 명세를 넣는다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Python Docstring Goals</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170050Z">
        <seg>Python Docstring 목표</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Python accepts the control-L (i.e. ^L) form feed character as
whitespace; Many tools treat these characters as page separators, so
you may use them to separate pages of related sections of your file.
Note, some editors and web-based code viewers may not recognize
control-L as a form feed and will show another glyph in its place.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150621Z">
        <seg>파이썬은 컨트롤-L(^L) 폼 피드 문자를 공백으로 취급한다. 많은 프로그램이
이 문자를 페이지 구분자로 취급하며, 파일 내에서 서로 연관성이
있는 단락을 페이지별로 구분하는데 이 문자를 사용할 수 있다.  특정
편집기나 웹 기반의 코드 뷰어는 컨트롤-L을 폼 피드 문자로 인식하지
않을 수도 있으며, 이 경우 폼 피드를 대신하는 다른 문자가 컨트롤-L
문자의 위치에 표시될 것이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Python coders from non-English speaking countries: please write your
comments in English, unless you are 120% sure that the code will never
be read by people who don't speak your language.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151841Z">
        <seg>비영어권 국가의 파이썬 코더의 경우, 다른 나라의 개발자가 현재 당신이
작성하는 코드를 읽게 될 일이 전혀 없으리란 확신이 들지 않는다면, 부
디 영문으로 주석을 작성해주길 바란다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Python mangles these names with the class name: if class Foo has an
attribute named ``__a``, it cannot be accessed by ``Foo.__a``.  (An
insistent user could still gain access by calling ``Foo._Foo__a``.)
Generally, double leading underscores should be used only to avoid
name conflicts with attributes in classes designed to be subclassed.</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130527T162424Z">
        <seg>파이썬은 이러한 이름에 클래스 이름을 결합하여 네임 맹글링을 수행한다
: 만약 Foo 클래스가 ``__a``\ 라는 이름의 어트리뷰트를 갖고 있다면, 이
어트리뷰트는 ``Foo.__a`` 같은 코드로 접근할 수 없다.  (집요한 사용자라면
``Foo._Foo__a``\ 를 호출하여 이 어트리뷰트에 접근할 수 있다.)
일반적으로  두 개의 언더스코어 문자를 앞에 붙이는 방법은 상속이
일어나도록 설계된 클래스 내의 어트리뷰트에서 일어나는 이름 충돌을 피할
때에만 사용해야 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Python's BDFL
-------------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T124956Z">
        <seg>파이썬의 BDFL
-------------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rather not::</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151653Z">
        <seg>권장하지 않음::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rationale</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T130621Z">
        <seg>근거</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rationale
---------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T130709Z">
        <seg>근거
----</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rationale
=========</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T131213Z">
        <seg>근거
====</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReStructuredText PEP Formatting Requirements
============================================</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T163533Z">
        <seg>ReStructuredText PEP Formatting 요건
====================================</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>ReStructuredText_ PEPs allow for rich markup that is still quite easy
to read, but results in much better-looking and more functional HTML.
PEP 12 contains instructions and a template [4]_ for reStructuredText
PEPs.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T044738Z">
        <seg>ReStructuredText_ PEP는 다양한 markup을 사용하여, 여전히 읽기는 쉬우면서도
더 보기 좋고 기능적인 HTML을 만들어낼 수 있다. PEP 12에 reStructuredText
PEP를 작성하는 방법에 대한 설명과 템플릿\ [4]_\ 이 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reference Implementation</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T164555Z">
        <seg>참조 구현</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>References</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125950Z">
        <seg>참조</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>References
    ==========</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T163308Z">
        <seg>참조
    ====</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>References
----------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T130758Z">
        <seg>참조
----</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>References
==========</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T130606Z">
        <seg>참조
====</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>References and Footnotes
========================</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T041603Z">
        <seg>참조 및 각주
============</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Rejected Changes</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170512Z">
        <seg>변경 거부</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Related PEPs</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165517Z">
        <seg>관련된 PEP</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Release Manager</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T131552Z">
        <seg>릴리스 관리자</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Release Schedule</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T131544Z">
        <seg>릴리스 일정</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Release Schedule
    [revised 5 Oct 2000]</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T164349Z">
        <seg>릴리스 일정
    [revised 5 Oct 2000]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Replacement Note</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T164231Z">
        <seg>대체 노트</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Reporting PEP Bugs, or Submitting PEP Updates
=============================================</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T010037Z">
        <seg>PEP 버그 보고 및 PEP 수정 제출
==============================</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resources
=========</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T163107Z">
        <seg>자원
====</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Resources:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T041352Z">
        <seg>자원:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scenario 1:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165712Z">
        <seg>시나리오 1:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scenario 2:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165717Z">
        <seg>시나리오 2:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scenario 3:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165722Z">
        <seg>시나리오 3:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Schedule</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T164316Z">
        <seg>일정</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Scope</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T130257Z">
        <seg>범위</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Security Issues</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165956Z">
        <seg>보안 이슈</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Semantics</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170615Z">
        <seg>시맨틱</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Semantics
 
     Attribute references of all three kinds should call the method.
     The op parameter can be "get"/"set"/"del". Of course this string
     will be interned so the actual checks for the string will be
     very fast.
 
     It is disallowed to actually have an attribute named XXX in the
     same instance as a method named __attr_XXX__.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165754Z">
        <seg>시맨틱
 
     Attribute references of all three kinds should call the method.
     The op parameter can be "get"/"set"/"del". Of course this string
     will be interned so the actual checks for the string will be
     very fast.
 
     It is disallowed to actually have an attribute named XXX in the
     same instance as a method named __attr_XXX__.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Separate top-level function and class definitions with two blank
lines.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150535Z">
        <seg>최상위 수준 함수와 클래스 정의는 두 줄을 띄워서 구분한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since module names are mapped to file names, and some file systems are
case insensitive and truncate long names, it is important that module
names be chosen to be fairly short -- this won't be a problem on Unix,
but it may be a problem when the code is transported to older Mac or
Windows versions, or DOS.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153123Z">
        <seg>위와 같이 하는 이유는 모듈 이름이 파일 이름에 직접적으로 대응되며,
특정한 파일 시스템에서는 대소문자가 무시되고 긴 이름이 잘려나가기 때문이다.
그러므로 모듈 이름을 가급적 짧게 짓는 것은 중요한 일이다 --
유닉스 시스템에서는 별 문제가 없겠지만 구형 맥, 윈도우, 도스 등으로
이 코드를 옮겼을 때 문제가 될 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Software covered by the GNU General Public License</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165113Z">
        <seg>GNU 공중 라이선스를 따르는 소프트웨어</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Solution</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165303Z">
        <seg>해결 방안</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Some Informational and Process PEPs may also have a status of "Active"
if they are never meant to be completed.  E.g. PEP 1 (this PEP).</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125441Z">
        <seg>의도적으로 완료시키지 않는 몇몇 정보 및 프로세스 PEP는 "활성(Active)" 상태를
가질 수 있다.  지금 보고 있는 PEP 1이 그 예이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Specification</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165327Z">
        <seg>명세</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Standard Library</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T171530Z">
        <seg>표준 라이브러리</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Standards Track PEPs consist of two parts, a design document and a
reference implementation.  It is generally recommended that at least a
prototype implementation be co-developed with the PEP, as ideas that sound
good in principle sometimes turn out to be impractical when subjected to the
test of implementation.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125237Z">
        <seg>표준 트랙 PEP는 설계 문서와 참조 구현의 두 부분으로 이루어진다.  일반적으로
최소한 프로토타입 구현을 PEP와 함께 개발하는 것을 권장하는데, 이는
이론적으로는 괜찮아보이는 아이디어가 실제 구현을 테스트해보면 실용적이지
못한 것으로 판명되는 경우가 있기 때문이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Standards Track PEPs will typically have a Python-Version header which
indicates the version of Python that the feature will be released with.
Standards Track PEPs without a Python-Version header indicate
interoperability standards that will initially be supported through
external libraries and tools, and then supplemented by a later PEP to
add support to the standard library. Informational and Process PEPs do
not need a Python-Version header.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130605T063523Z">
        <seg>표준 트랙 PEP는 일반적으로 그 기능이 릴리스될 파이썬 버전을 가리키는
Python-Version 헤더를 갖는다.  Python-Version 헤더가 없는 표준 트랙
PEP는, 처음에는 외부 라이브러리 및 도구를 통해 상호 운용이 가능한
표준으로 하였다가, 나중에 표준 라이브러리에 포함시키는 경우이다.  정보
및 프로세스 PEP에는 Python-Version 헤더가 필요하지 않다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Steps For Introducing Backwards-Incompatible Features</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T130410Z">
        <seg>하위 호환되지 않는 기능을 도입하기 위한 절차</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String exceptions in new code are forbidden, and this language
  feature has been removed in Python 2.6.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154551Z">
        <seg>앞으로 작성되는 코드에서는 문자열 예외가 금지되며, 문자열 예외
  기능은 파이썬 2.6에서 제거되었다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>String methods are always much faster and share the same API with
  unicode strings.  Override this rule if backward compatibility with
  Pythons older than 2.0 is required.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T155105Z">
        <seg>문자열 메서드는 항상 좀 더 빠르며 유니코드 문자열과 동일한 API를
  공유하고 있다.  파이썬 2.0 이하 버전과의 하위 호환성이 필요한 경우에는
  이 규칙을 무시해도 된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Submitting a PEP
----------------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125044Z">
        <seg>PEP 제출
--------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Syntax</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170608Z">
        <seg>구문</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tables
------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T163347Z">
        <seg>표
--</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tabs or Spaces?
---------------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150245Z">
        <seg>탭이냐 공백이냐
---------------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Author header lists the names, and optionally the email addresses
of all the authors/owners of the PEP.  The format of the Author header
value must be</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130605T063326Z">
        <seg>Author 헤더에는 PEP 저자 및 소유자의 이름을 나열하며, 이메일 주소를 함께
쓸 수 있다.  Author 헤더의 값은 반드시 다음과 같은 형식으로 기재한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The BDFL-Delegate field is used to record cases where the final decision to
approve or reject a PEP rests with someone other than the BDFL. (The
delegate's email address is currently omitted due to a limitation in the
email address masking for reStructuredText PEPs)</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130605T063404Z">
        <seg>BDFL-Delegate 필드는 PEP의 수용 또는 거부에 대한 최종 결정을 BDFL이 아닌
다른 사람에게 위임한 경우에 사용한다. (위임받은 이의 이메일 주소는 현재
reStructuredText PEP의 이메일 주소 마스킹의 제약으로 인해 생략한다.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Created header records the date that the PEP was assigned a
number, while Post-History is used to record the dates of when new
versions of the PEP are posted to python-list and/or python-dev.  Both
headers should be in dd-mmm-yyyy format, e.g. 14-Aug-2001.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130605T063508Z">
        <seg>Created 헤더에는 PEP 번호를 부여한 날짜를 기록하고, Post-History는
새로운 버전의 PEP가 python-list 및 python-dev에 게재된 날짜를 기록한다.
두 헤더는 dd-mmm-yyyy 형식을 따르며, 14-Aug-2001과 같이 쓴다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The PEP editors are individuals responsible for managing the administrative
and editorial aspects of the PEP workflow (e.g. assigning PEP numbers and
changing their status).  See `PEP Editor Responsibilities &amp; Workflow`_ for
details.  The current editors are:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130605T064638Z">
        <seg>PEP 편집자는 PEP 흐름의 관리 및 편집(PEP 번호를 할당하고 각각의 상태를
변경하는 일 등)에 대한 책임을 맡는 개인이다.  자세한 내용은 `PEP 편집자의
책임 및 흐름`_\ 을 참조하라.  현재 활동 중인 편집자는 다음과
같다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The PEP process begins with a new idea for Python.  It is highly
recommended that a single PEP contain a single key proposal or new
idea. Small enhancements or patches often don't need
a PEP and can be injected into the Python development workflow with a
patch submission to the Python `issue tracker`_. The more focused the
PEP, the more successful it tends to be.  The PEP editors reserve the
right to reject PEP proposals if they appear too unfocused or too
broad.  If in doubt, split your PEP into several well-focused ones.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T042200Z">
        <seg>PEP 프로세스는 파이썬에 대한 새로운 아이디어로부터 시작한다.  단일한 PEP는 단
하나의 주요 제안 또는 새로운 아이디어만을 담도록 하는 것을 강력히 권장한다.
사소한 개선이나 패치는 종종 PEP를 거치지 않고 파이썬 `이슈 트래커`_\ 에
패치를 제출함으로써 파이썬 개발 흐름에 포함시킬 수 있다.  PEP는 초점이 잘
잡혀 있을 수록 성공하기 쉽다.  PEP 편집자는 초점이 맞지 않거나 너무 광범위한
PEP를 거부할 수 있다.  의심스럽다면 PEP를 초점이 잘 잡힌 여러 개의 PEP로
분할하도록 하라.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Proposed Solution</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T164854Z">
        <seg>제안된 해결책</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Type header specifies the type of PEP: Standards Track,
Informational, or Process.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130605T063439Z">
        <seg>Type 헤더에는 Standards Track(표준 트랙), Informational(정보) 또는
Process(프로세스) 등과 같이 PEP의 종류를 기재한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The X11 library uses a leading X for all its public functions.  In
Python, this style is generally deemed unnecessary because attribute
and method names are prefixed with an object, and function names are
prefixed with a module name.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T152801Z">
        <seg>X11 라이브러리는 public 함수에 모두 X라는 접두사를 사용하고 있다.
파이썬에서 이러한 스타일은 일반적으로 쓸데없는 짓으로 간주된다.
어트리뷰트와 메서드에 접근할 때에는 객체를 접두사로 사용하며, 함수에
접근할 때에는 모듈 이름을 접두사로 사용하기 때문이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Zen of Python</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T162949Z">
        <seg>파이썬 선(禪)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The closing brace/bracket/parenthesis on multi-line constructs may
either line up under the last item of the list, as in::</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130527T161022Z">
        <seg>여러 줄에 걸친 괄호/중괄호/대괄호를 닫을 경우 리스트의 마지막 항목에
맞추어 다음 줄에 닫는 표시를 할 수 있다. 다음 코드를 보자. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The exception is if your code must work with Python 1.5.2 (but let's
  hope not!).</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T155200Z">
        <seg>예외적으로, 파이썬 1.5.2에서 동작하는 코드를 작성해야 할 경우는 후자의
  코드를 사용한다(그런 일이 없기를!).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final authority for PEP approval is the BDFL. However, whenever a new
PEP is put forward, any core developer that believes they are suitably
experienced to make the final decision on that PEP may offer to serve as
the BDFL's delegate (or "PEP czar") for that PEP. If their self-nomination
is accepted by the other core developers and the BDFL, then they will have
the authority to approve (or reject) that PEP. This process happens most
frequently with PEPs where the BDFL has granted in principle approval for
*something* to be done, but there are details that need to be worked out
before the PEP can be accepted.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125315Z">
        <seg>PEP 승인의 최종 결정권자는 BDFL이다.  그러나, 새로운 PEP마다, 충분한 경험을
갖추고 최종 결정을 내릴 수 있는 핵심 개발자가 BDFL의 위임자(또는 "PEP
황제")로서 봉사할 수 있다.  그들의 자기 추천이 다른 핵심 개발자와 BDFL에
의해 받아들여지면, 해당 PEP에 대한 승인(또는 거부)의 권한을 갖게 된다.
이 프로세스는 BDFL이 *무언가가* 이루어지는 데에 원칙적으로는 수용을
허락하였지만, 그 PEP를 수용하기 위해 해야할 일들이 남아있는 경우에 자주
일어난다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The final implementation must include test code and documentation
   appropriate for either the Python language reference or the
   standard library reference.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125709Z">
        <seg>최종 구현은 테스트 코드와 함께, 파이썬 언어 레퍼런스 또는 표준 라이브러리
   레퍼런스에 적합한 문서를 반드시 포함하여야 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following is a PEP-specific summary of reStructuredText syntax.
For the sake of simplicity and brevity, much detail is omitted.  For
more detail, see `Resources`_ below.  `Literal blocks`_ (in which no
markup processing is done) are used for examples throughout, to
illustrate the plaintext markup.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T061323Z">
        <seg>The following is a PEP-specific summary of reStructuredText syntax.
For the sake of simplicity and brevity, much detail is omitted.  For
more detail, see `자원`_ below.  `Literal blocks`_ (in which no
markup processing is done) are used for examples throughout, to
illustrate the plaintext markup.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The following naming styles are commonly distinguished:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T152554Z">
        <seg>다음과 같은 명명 스타일을 흔히 볼 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The format of a PEP is specified with a Content-Type header.  The
acceptable values are "text/plain" for plaintext PEPs (see PEP 9 [3]_)
and "text/x-rst" for reStructuredText PEPs (see PEP 12 [4]_).
Plaintext ("text/plain") is the default if no Content-Type header is
present.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T044850Z">
        <seg>PEP의 형식은 Content-Type 헤더에 지정한다.  사용할 수 있는 값으로는 일반
텍스트 PEP를 의미하는 "text/plain"(PEP 9 참조 [3]_)와 reStructuredText
PEP를 의미하는 "text/x-rst"(PEP 12 참조 [4]_ )가 있다.  Content-Type
헤더를 지정하지 않은 경우에는 일반 텍스트("text/plain")를 기본값으로
한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The latest version of this document is always available at:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T164015Z">
        <seg>이 문서의 최종 버전은 다음 주소에서 항상 볼 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The latter example doesn't provide any information to indicate that
  the __enter__ and __exit__ methods are doing something other than
  closing the connection after a transaction.  Being explicit is
  important in this case.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T155033Z">
        <seg>후자의 예를 살펴보면 __enter__, __exit__ 메서드가 트랜잭션 이후에
  커넥션을 닫는다는 것 외에는 어떤 일을 하는지에 대한 정보를 제공하지
  않는 것을 볼 수 있다.  이러한 경우 명시적인 정보를 제공하는 것은
  중요하다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The mercurial repo for the peps is::</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T040242Z">
        <seg>PEP 머큐리얼 저장소::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The most popular way of indenting Python is with spaces only.  The
second-most popular way is with tabs only.  Code indented with a
mixture of tabs and spaces should be converted to using spaces
exclusively.  When invoking the Python command line interpreter with
the ``-t`` option, it issues warnings about code that illegally mixes
tabs and spaces.  When using ``-tt`` these warnings become errors.
These options are highly recommended!</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150347Z">
        <seg>파이썬에서 들여쓰기에 주로 사용되는 방식은 공백 문자만 사용하는 것이다.
두 번째로 많이 쓰이는 방식은 탭 문자만 사용하는 것이다.  탭 문자와
공백 문자가 섞인 코드는 반드시 공백 문자만 사용한 코드로 변환해야 한다.
``-t`` 옵션을 사용하여 파이썬 명령줄 인터프리터를 호출하면 탭 문자와
공백 문자가 섞인 코드가 있을 경우 인터프리터가 경고 메시지를 표시한다.
``-tt`` 옵션을 사용하면 이 경고 메시지가 에러 메시지로 표시된다.
위 옵션들을 사용하기를 권한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The naming conventions of Python's library are a bit of a mess, so
we'll never get this completely consistent -- nevertheless, here are
the currently recommended naming standards.  New modules and packages
(including third party frameworks) should be written to these
standards, but where an existing library has a different style,
internal consistency is preferred.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T152449Z">
        <seg>파이썬 라이브러리의 명명 규칙은 난잡하기 때문에, 이 라이브러리에 완벽하게
일관성을 적용하는 일은 없을 것이다.  어쨌든, 현재 권장되는 명명 규칙에
대한 표준을 여기 기술한다.  새로운 모듈과 패키지(서드 파티 프레임워크를
포함한)는 이들 표준에 맞추어 작성되어야 하지만, 이미 다른 스타일로
작성되어 있는 기존 라이브러리는 그 자체의 일관성을 유지하도록 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The paren-using form is preferred because when the exception
  arguments are long or include string formatting, you don't need to
  use line continuation characters thanks to the containing
  parentheses.  The older form is not legal syntax in Python 3.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154703Z">
        <seg>괄호를 사용하는 구문을 권장하는 이유는, 예외의 인수가 긴 문자열이거나
  문자열 형식화를 사용할 경우에 여러 줄을 이어서 작성하기가 좀
  더 편리하기 때문이다.  파이썬 3에서 괄호를 사용하지 않은 예외
  발생 구문은 틀린 문법이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The possible paths of the status of PEPs are as follows:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125430Z">
        <seg>PEP가 가질 수 있는 상태는 다음과 같다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The preferred way of wrapping long lines is by using Python's implied
line continuation inside parentheses, brackets and braces.  Long lines
can be broken over multiple lines by wrapping expressions in
parentheses. These should be used in preference to using a backslash
for line continuation.  Make sure to indent the continued line
appropriately.  The preferred place to break around a binary operator
is *after* the operator, not before it.  Some examples::</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130527T161123Z">
        <seg>글자가 많은 행에 줄바꿈을 적용할 경우 좋은 방법은 괄호, 중괄호, 대괄호
등의 내부에 여러 행의 코드를 적는 것이다.  파이썬에서 이들 코드는
암시적으로 계속 이어지는 것으로 처리된다.  괄호를 사용한 줄바꿈을 적용하여
긴 코드를 여러 행의 코드로 바꿀 수 있다.  이 방법은 줄이 계속됨을
나타내는 백슬래시('\') 문자를 사용하기 전에 사용해야 한다.  이진
연산자에서 줄바꿈을 할 경우 줄바꿈하기 좋은 곳은 연산자의 *다음*
위치이다(이전 위치가 아니다).  몇 가지 예를 살펴보자. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The rationale should provide evidence of consensus within the
   community and discuss important objections or concerns raised
   during discussion.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125634Z">
        <seg>근거에서는 커뮤니티의 내에서 합의가 이루어졌음을 증명하고 논의 과정에서
   있었던 중요한 반대나 우려에 대하여 논의하여야 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are a lot of different naming styles.  It helps to be able to
recognize what naming style is being used, independently from what
they are used for.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T152538Z">
        <seg>세상에는 다양한 명명 스타일이 존재한다.  명명 스타일은 이 스타일이
어떤 목적으로 쓰이는지와는 별개로, 어떤 명명 스타일이 쓰이고 있는지
알아보는데 도움이 된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are several reference in this PEP to the "BDFL". This acronym stands
for "Benevolent Dictator for Life" and refers to Guido van Rossum, the
original creator of, and the final design authority for, the Python
programming language.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125004Z">
        <seg>이 PEP에는 "BDFL"이 여러 번 등장한다.  이는 "Benevolent Dictator for Life
(친절한 종신 독재자)"의 약어로서, 파이썬 프로그래밍 언어를 최초로
고안하였으며, 최종적인 디자인 결정권을 가진 Guido van Rossum을 지칭한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are some tools already in existence that take advantage of a
smaller set of pseudo-codetags (see References_).  There is also an
example codetags implementation under way, known as the `Codetag
Project`__.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T060910Z">
        <seg>There are some tools already in existence that take advantage of a
smaller set of pseudo-codetags (see 참조_).  There is also an
example codetags implementation under way, known as the `Codetag
Project`__.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are still many devices around that are limited to 80 character
lines; plus, limiting windows to 80 characters makes it possible to
have several windows side-by-side.  The default wrapping on such
devices disrupts the visual structure of the code, making it more
difficult to understand.  Therefore, please limit all lines to a
maximum of 79 characters.  For flowing long blocks of text (docstrings
or comments), limiting the length to 72 characters is recommended.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150448Z">
        <seg>세상에는 한 행에 80글자까지만 표시할 수 있는 장비들이 아직 많이 남아
있다.  게다가, 창 하나에 80글자만 표시하도록 강제할 경우 여러 창을
열어서 늘어놓고 작업할 수 있다.  80글자 제한이 있는 장치에서 자동 줄바꿈
(wrapping)이 일어날 경우 코드의 시각적인 구조가 망가지며, 이렇게
되면 코드를 이해하기 어려워진다.  그러므로 코드 한 행은 최대 79글자로
제한하도록 하자.  텍스트가 길게 이어지는 경우(docstring 혹은 주석문)에는
72글자로 제한하는 것을 권장한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are three kinds of PEP:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T124458Z">
        <seg>PEP에는 다음의 세 가지 종류가 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There are two PEP formats available to authors: plaintext and
reStructuredText_.  Both are UTF-8-encoded text files.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125734Z">
        <seg>저자가 사용할 수 있는 PEP 형식에는 일반 텍스트와 reStructuredText_\ 의
두 가지가 있다.  양쪽 다 UTF-8 인코딩의 텍스트 파일이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There is a Python script that converts both styles of PEPs to HTML for
viewing on the web [5]_.  Parsing and conversion of plaintext PEPs is
self-contained within the script.  reStructuredText PEPs are parsed
and converted by Docutils_ code called from the script.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T044811Z">
        <seg>각 스타일의 PEP를 웹에서 보여질 HTML로 변환하는 파이썬 스크립트가 있다. [5]_
일반 텍스트 PEP의 분석과 변환은 스크립트 내에 포함되어 있다.
reStructuredText PEP는 스크립트에서 호출하는 Docutils_ 코드에 의하여 변환된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>There's also the style of using a short unique prefix to group related
names together.  This is not used much in Python, but it is mentioned
for completeness.  For example, the ``os.stat()`` function returns a
tuple whose items traditionally have names like ``st_mode``,
``st_size``, ``st_mtime`` and so on.  (This is done to emphasize the
correspondence with the fields of the POSIX system call struct, which
helps programmers familiar with that.)</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T152743Z">
        <seg>서로 연관이 있는 명칭들을 통합하기 위해 짧은 고유 접두사를 사용하는
스타일 또한 존재한다.  파이썬에서는 이러한 스타일이 많이 쓰이지 않고
있으나, 이 문서의 완결성을 위해 언급해둔다.  예를 들어 ``os.stat()``
함수는 전통적으로 ``st_mode``, ``st_size``, ``st_mtime`` 등의 이름을
가진 항목이 담긴 튜플을 반환한다.  (이들은 POSIX 시스템 호출 구조체의
필드와 관련이 있음을 강조하기 위해 쓰인 것이다. POSIX에 익숙한 
프로그래머에게는 도움이 된다.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These lines should be included after the module's docstring, before
any other code, separated by a blank line above and below.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T152335Z">
        <seg>위 내용은 모듈의 docstring 바로 다음에 와야 하며, 그 이후에는 프로그램
코드가 온다. 그리고 이 행의 위와 아래에는 빈 줄 한 개씩이 들어가야
한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This PEP contained guidelines for handling bug reports in 
    the Python bug tracker.  It has been replaced by the Issue Workflow
    described at</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T062159Z">
        <seg>이 PEP는 Python 버그 트래커에서 버그 리포트를 다루는 것에 대한 안내를
    담고 있다.  다음에서 기술하는 이슈 작업흐름에 의하여 대체되었다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This PEP has been superseded by the updated material in the Python
    Developer's Guide [1].</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T063513Z">
        <seg>이 PEP는 Python 개발자 안내서의 새로운 내용으로 대체되었다. [1]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document and PEP 257 (Docstring Conventions) were adapted from
Guido's original Python Style Guide essay, with some additions from
Barry's style guide [2]_.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T145748Z">
        <seg>이 문서와 PEP 257(Docstring 규칙)은 귀도가 작성한 파이썬 스타일 가이드에
관한 짧은 글에 바탕을 두고 있으며, 후에 배리의 스타일 가이드 [2]\ 에서
일부 내용을 추가하였다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document gives coding conventions for the C code comprising the C
implementation of Python.  Please see the companion informational PEP
describing style guidelines for Python code [1]_.</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130612T044507Z">
        <seg>이 문서는 파이썬의 C 구현을 구성하는 C 코드에 대한 코딩 관례를 제시한다.
파이썬 코드에 대한 스타일 안내를 기술하는 정보 PEP를 함께 보기를 권한다
[1]_.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document gives coding conventions for the Python code comprising
the standard library in the main Python distribution.  Please see the
companion informational PEP describing style guidelines for the C code
in the C implementation of Python [1]_.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T145735Z">
        <seg>이 문서는 기본 파이썬 배포판의 표준 라이브러리를 구성하는 파이썬 코드의
코딩 규칙(coding convention)을 설명한다.  파이썬의 C 구현에 대한
스타일 가이드라인을 설명하는 PEP [1]\ 도 참고하길 바란다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document has been placed in the Public Domain.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170306Z">
        <seg>이 문서는 퍼블릭 도메인에 속한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document has been placed in the public domain.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T120821Z">
        <seg>이 문서는 퍼블릭 도메인에 속한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document is in the public domain.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165943Z">
        <seg>이 문서는 퍼블릭 도메인에 속한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document is licensed under the `Open Publication License`_.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T060807Z">
        <seg>This document is licensed under the `공개 출판 라이선스`_.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This document is placed in the public domain.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T165506Z">
        <seg>이 문서는 퍼블릭 도메인에 속한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This option does not solve issues listed in the `Rationale`_
section, it only provides an helper to fix them. All functions creating
file descriptors have to be modified to set *cloexec=True* in each
module used by an application to fix all these issues.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T054812Z">
        <seg>This option does not solve issues listed in the `근거`_
section, it only provides an helper to fix them. All functions creating
file descriptors have to be modified to set *cloexec=True* in each
module used by an application to fix all these issues.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To avoid name clashes with subclasses, use two leading underscores to
invoke Python's name mangling rules.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153713Z">
        <seg>서브클래스와의 이름 충돌을 피하기 위해, 앞에 두 개의 언더스코어를 붙여
파이썬의 네임 맹글링 규칙을 따른다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To minimize the effort involved, the ``functools.total_ordering()``
  decorator provides a tool to generate missing comparison methods.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T154453Z">
        <seg>``functools.total_ordering()`` 데코레이터는 구현되지 않은 비교 연산
  메서드를 자동으로 생성해주는 도구를 제공하므로, 이러한 구현에
  들어가는 노력을 최소화할 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Tools</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T171546Z">
        <seg>도구</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Transferring PEP Ownership
==========================</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T012004Z">
        <seg>PEP 소유권의 이양
=================</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Two good reasons to break a particular rule:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T145840Z">
        <seg>특정한 규칙을 무시해도 괜찮은 두 가지 경우를 살펴보자.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unresolved Issues</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T171128Z">
        <seg>미해결 사항</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unresolved Issues
 
    Do we need to make it possible to disable the 3 hard-wired modules
    without manually hacking the Makefiles?  [Answer: No.]</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T171203Z">
        <seg>미해결 사항
 
    Do we need to make it possible to disable the 3 hard-wired modules
    without manually hacking the Makefiles?  [Answer: No.]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unresolved Issues
      
    Is there a way to escape characters in ST? If so, how? 
    (example: * at the beginning of a line without being bullet symbol)</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T170119Z">
        <seg>미해결 사항
      
    Is there a way to escape characters in ST? If so, how? 
    (example: * at the beginning of a line without being bullet symbol)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Unsupporting platforms
----------------------</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T130727Z">
        <seg>지원하지 않는 플랫폼
--------------------</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Updates to existing PEPs also come in to peps@python.org.  Many PEP
authors are not Python committers yet, so PEP editors do the commits for them.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T043751Z">
        <seg>기존의 PEP에 대한 수정 또한 peps@python.org\ 에 들어온다.  많은 PEP 저자는 아직
Python 커미터가 아니므로, PEP 편집자가 대신에 커밋을 해준다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use 4 spaces per indentation level.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150005Z">
        <seg>4개의 공백을 들여쓰기의 단위로 사용하라.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use blank lines in functions, sparingly, to indicate logical sections.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T150600Z">
        <seg>함수 내에서 논리적인 단위를 드러내기 위해 빈 줄을 사용하라. (하지만
아껴서 사용하자)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use inline comments sparingly.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T152025Z">
        <seg>인라인 주석문은 아껴서 사용한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use one leading underscore only for non-public methods and instance
variables.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153703Z">
        <seg>비 public 메서드/인스턴스 변수의 경우 앞에 언더스코어 문자를 하나 붙인다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Use the function naming rules: lowercase with words separated by
underscores as necessary to improve readability.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153648Z">
        <seg>다음 함수 명명 규칙을 사용한다: 소문자로 된 단어를 사용하며, 각 단어는
필요에 따라 가독성을 높이기 위해 언더스코어로 구분한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Version Bookkeeping
===================</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T152245Z">
        <seg>버전 관리
=========</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Vetting an idea publicly before going as far as writing a PEP is meant
to save the potential author time. Many ideas have been brought
forward for changing Python that have been rejected for various
reasons. Asking the Python community first if an idea is original
helps prevent too much time being spent on something that is
guaranteed to be rejected based on prior discussions (searching
the internet does not always do the trick). It also helps to make sure
the idea is applicable to the entire community and not just the author.
Just because an idea sounds good to the author does not
mean it will work for most people in most areas where Python is used.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125126Z">
        <seg>PEP를 작성하기에 앞서 아이디어를 공개적으로 검토함으로써 저자의 시간을
절약할 수 있다.  파이썬에 변경을 일으킬 수 있는 많은 아이디어가 여러 이유로
인해 기각된다.  이전의 논의에 의거하여 기각될 것이 자명한 아이디어에 불필요한
시간을 낭비하지 않도록 파이썬 커뮤니티에 먼저 물어보라(인터넷을 찾아보는
것이 능사는 아니다).  또한 저자만이 아니라 전체 커뮤니티에 적용이 가능한지
확인하는 것도 도움이 된다.  저자가 생각하기에 좋은 아이디어라 할지라도
파이썬을 사용하는 대다수의 영역의 사람들에게도 그렇지는 않을 수도 있기
때문이다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Warnings and Errors</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T131706Z">
        <seg>경고 및 오류</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We don't use the term "private" here, since no attribute is really
private in Python (without a generally unnecessary amount of work).</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153848Z">
        <seg>여기서는 "private"이란 단어를 사용하지 않는다.  사실 파이썬에는
private 어트리뷰트가 존재하지 않기 때문이다 (필요 이상의 작업을 동원하지
않을 경우에 그렇다는 이야기이다).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We intend PEPs to be the primary mechanisms for proposing major new
features, for collecting community input on an issue, and for
documenting the design decisions that have gone into Python.  The PEP
author is responsible for building consensus within the community and
documenting dissenting opinions.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T124914Z">
        <seg>우리의 의도는 PEP가 굵직한 새 기능에 대한 제안을 하는 기본적인 메커니즘이
되며, 이슈에 대한 커뮤니티의 의견을 수렴하고, 파이썬에 적용하게 될 설계상의
결정에 대한 기록이 되도록 하는 것이다. PEP의 저자는 지역 사회 내에서 합의를
구축하고 반대 의견을 문서화 할 책임이 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What belongs in a successful PEP?
=================================</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125510Z">
        <seg>성공적인 PEP의 요소
===================</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What is a PEP?
==============</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T123030Z">
        <seg>PEP의 정의
==========</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a PEP is Accepted, Rejected or Withdrawn, the PEP should be updated
accordingly. In addition to updating the status field, at the very least
the Resolution header should be added with a link to the relevant post
in the python-dev mailing list archives.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T125415Z">
        <seg>PEP가 수용(Accepted), 거부 또는 철회되면, 그에 따라 PEP를 갱신하여야 한다.
상태 필드를 갱신함에 덧붙여, python-dev 메일링 리스트 아카이브의 관련된
게시물을 링크하는 최소한의 Resolution header를 추가하도록 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When an extension module written in C or C++ has an accompanying
Python module that provides a higher level (e.g. more object oriented)
interface, the C/C++ module has a leading underscore
(e.g. ``_socket``).</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153134Z">
        <seg>C/C++로 작성된 확장 모듈이 고수준 인터페이스(예를 들어 좀 더 객체
지향적인)를 제공하는 파이썬 모듈을 갖추고 있을 경우, 해당 C/C++ 모듈은
앞에 언더스코어를 사용한다 (예를 들면 ``_socket``).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When checking if an object is a string, keep in mind that it might
  be a unicode string too!  In Python 2.3, str and unicode have a
  common base class, basestring, so you can do::</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T155247Z">
        <seg>객체가 문자열인지 확인할 경우, 해당 문자열이 유니코드 문자열일 수도
  있다는 점을 명심하자.  파이썬 2.3에서는 str, unicode가 동일한
  기본 클래스인 basestring을 상속하므로 다음과 같은 구문을 사용할 수
  있다. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When in doubt about where to send your changes, please check first
with the PEP author and/or a PEP editor.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T011549Z">
        <seg>수정 사항을 어디에 보내야할지 확신이 서지 않는다면, PEP 저자 또는 편집자에게
먼저 문의하기 바란다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When new modules were added to the standard Python library in the
    past, it was not possible to foresee whether they would still be
    useful in the future.  Even though Python "Comes With Batteries
    Included", batteries may discharge over time.  Carrying old
    modules around is a burden on the maintainer, especially when
    there is no interest in the module anymore.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T062651Z">
        <seg>과거에 표준 파이썬 라이브러리에 새로운 모듈이 추가되었을 때에는,
    그것이 미래에도 계속 유용할 것인지 예상할 수 없었다. 파이썬의
    "배터리 포함"에도 불구하고, 배터리는 방전될 수 있다.  오래된
    모듈을 끌고가는 것은 관리자에게는 부담이 되며, 특히 그 모듈이
    더 이상 필요하지 않을 때에는 더욱 그러하다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When referencing an external web page in the body of a PEP, you should
include the title of the page in the text, with either an inline
hyperlink reference to the URL or a footnote reference (see
`Footnotes`_ below).  Do not include the URL in the body text of the
PEP.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T061117Z">
        <seg>When referencing an external web page in the body of a PEP, you should
include the title of the page in the text, with either an inline
hyperlink reference to the URL or a footnote reference (see
`각주`_ below).  Do not include the URL in the body text of the
PEP.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When writing English, Strunk and White apply.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151944Z">
        <seg>영문으로 작성할 경우 Strunk와 White의 스타일을 적용한다(역자 주: 영어 작문에 관한 책인 'The Elements of Style'의 저자).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Whitespace in Expressions and Statements
========================================</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151207Z">
        <seg>표현식, 구문에서의 공백 문자
============================</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Windows Notes</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T164249Z">
        <seg>Windows 참고</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With this in mind, here are the Pythonic guidelines:</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153914Z">
        <seg>파이썬의 다음과 같은 가이드라인을 마음에 새기도록 하자.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Withdrawal</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T171102Z">
        <seg>포기</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Yes:   if greeting:
      No:    if greeting == True:
      Worse: if greeting is True:</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130527T161748Z">
        <seg>좋음: if greeting:
      나쁨: if greeting == True:
      최악: if greeting is True:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Yes: dict['key'] = list[index]
      No:  dict ['key'] = list [index]</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130527T161343Z">
        <seg>좋음: dict['key'] = list[index]
      나쁨: dict ['key'] = list [index]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Yes: if foo.startswith('bar'):
      No:  if foo[:3] == 'bar':</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130527T161642Z">
        <seg>좋음: if foo.startswith('bar'):
      나쁨: if foo[:3] == 'bar':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Yes: if isinstance(obj, int):</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T155219Z">
        <seg>좋음: if isinstance(obj, int):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Yes: if not seq:
           if seq:</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130527T161720Z">
        <seg>좋음: if not seq:
            if seq:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Yes: if x == 4: print x, y; x, y = y, x
      No:  if x == 4 : print x , y ; x , y = y , x</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130527T161333Z">
        <seg>좋음: if x == 4: print x, y; x, y = y, x
      나쁨: if x == 4 : print x , y ; x , y = y , x</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Yes: import os
           import sys</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130527T161212Z">
        <seg>좋음: import os
            import sys</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Yes: spam(1)
      No:  spam (1)</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130527T161338Z">
        <seg>좋음: spam(1)
      나쁨: spam (1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Yes: spam(ham[1], {eggs: 2})
      No:  spam( ham[ 1 ], { eggs: 2 } )</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130527T161328Z">
        <seg>좋음: spam(ham[1], {eggs: 2})
      나쁨: spam( ham[ 1 ], { eggs: 2 } )</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Yes::</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151504Z">
        <seg>좋음::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should put a blank line between each group of imports.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151000Z">
        <seg>각 그룹 사이에는 빈 줄 하나를 넣어야 한다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should use two spaces after a sentence-ending period.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151825Z">
        <seg>문장의 마침표 다음에는 두 개의 공백을 넣는다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[1] Adding to the Stdlib
        http://docs.python.org/devguide/stdlibchanges.html</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T061925Z">
        <seg>[1] Stdlib에 추가하기
        http://docs.python.org/devguide/stdlibchanges.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`Footnotes`_
============</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130610T061102Z">
        <seg>`각주`_
=======</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>`single-quoted' or ``double-quoted''</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T163157Z">
        <seg>`single-quoted' 또는 ``double-quoted''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and use "myclass.MyClass" and "foo.bar.yourclass.YourClass".</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T151154Z">
        <seg>그런 다음 "myclass.MyClass", "foo.bar.yourclass.YourClass" 같은
  식으로 클래스를 사용하면 된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if the address is not given.  For historical reasons the format
"address@dom.ain (Random J. User)" may appear in a PEP, however new
PEPs must use the mandated format above, and it is acceptable to
change to this format when PEPs are updated.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130605T063342Z">
        <seg>주소가 없을 경우 위와 같이 쓰면 된다.  과거의 PEP에는
"address@dom.ain (Random J. User)"와 같은 형식으로 쓰여진 것이 남아
있을 수도 있지만, 새롭게 쓰여지는 PEP는 위의 형식을 따라야 하며,
기존의 PEP를 갱신할 때에 새로운 형식으로 변경할 수 있다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>if the email address is included, and just</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong CHOI" changedate="20130605T052609Z">
        <seg>이메일 주소가 있을 경우에는 위와 같이 쓰고,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>mixedCase is allowed only in contexts where that's already the
prevailing style (e.g. threading.py), to retain backwards
compatibility.</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T153328Z">
        <seg>mixedCase 스타일의 경우, 이미 mixedCase 스타일을 따르고 있는 모듈
(예: threading.py)에서만 하위 호환성 유지를 위해 허용된다.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>or it may be lined up under the first character of the line that
starts the multi-line construct, as in::</seg>
      </tuv>
      <tuv lang="KO" changeid="yong" changedate="20130527T161032Z">
        <seg>혹은 이렇게 여러 줄에 걸친 코드의 첫 번째 문자 위치에 닫는 표시를 넣을
수도 있다. 다음 코드를 보자. ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>startswith() and endswith() are cleaner and less error prone.  For
  example::</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T155136Z">
        <seg>startswith()와 endswith()는 의미가 명확하므로 오류가 발생할 여지가
  적다. 예를 들면, ::</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>try:
          # Too broad!
          return handle_value(collection[key])
      except KeyError:
          # Will also catch KeyError raised by handle_value()
          return key_not_found(key)</seg>
      </tuv>
      <tuv lang="KO" changeid="Yong Choi" changedate="20130527T155015Z">
        <seg>try:
          # 코드 적용 범위가 넓다!
          return handle_value(collection[key])
      except KeyError:
          # 여기서는 handle_value()이 발생시킨 KeyError 예외를 처리
          return key_not_found(key)</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
